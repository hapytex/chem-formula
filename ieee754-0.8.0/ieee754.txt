-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for dealing with IEEE floating point numbers
--   
--   Utilities for dealing with IEEE floating point numbers, ported from
--   the Tango math library; approximate and exact equality comparisons for
--   general types.
@package ieee754
@version 0.8.0


-- | Operations on IEEE floating point numbers.
module Numeric.IEEE

-- | IEEE floating point types.
class (RealFloat a) => IEEE a

-- | Infinity value.
infinity :: IEEE a => a

-- | The smallest representable positive value.
minDenormal :: IEEE a => a

-- | The smallest representable positive normalized value.
minNormal :: IEEE a => a

-- | The largest representable finite value.
maxFinite :: IEEE a => a

-- | The smallest positive value <tt>x</tt> such that <tt>1 + x</tt> is
--   representable.
epsilon :: IEEE a => a

-- | <tt>copySign x y</tt> returns <tt>x</tt> with its sign changed to
--   <tt>y</tt>'s.
copySign :: IEEE a => a -> a -> a

-- | Return <a>True</a> if two values are <i>exactly</i> (bitwise) equal.
identicalIEEE :: IEEE a => a -> a -> Bool

-- | Return the next largest IEEE value (<tt>Infinity</tt> and <tt>NaN</tt>
--   are unchanged).
succIEEE :: IEEE a => a -> a

-- | Return the next smallest IEEE value (<tt>-Infinity</tt> and
--   <tt>NaN</tt> are unchanged).
predIEEE :: IEEE a => a -> a

-- | Given two values with the same sign, return the value halfway between
--   them on the IEEE number line. If the signs of the values differ or
--   either is <tt>NaN</tt>, the value is undefined.
bisectIEEE :: IEEE a => a -> a -> a

-- | The number of significand bits which are equal in the two arguments
--   (equivalent to <tt>feqrel</tt> from the Tango Math library). The
--   result is between <tt>0</tt> and <tt><a>floatDigits</a></tt>.
sameSignificandBits :: IEEE a => a -> a -> Int

-- | Default <tt>NaN</tt> value.
nan :: IEEE a => a

-- | Quiet <tt>NaN</tt> value with a positive integer payload. Payload must
--   be less than <a>maxNaNPayload</a>. Beware that while some platforms
--   allow using <tt>0</tt> as a payload, this behavior is not portable.
nanWithPayload :: IEEE a => Word64 -> a

-- | Maximum <tt>NaN</tt> payload for type <tt>a</tt>.
maxNaNPayload :: IEEE a => a -> Word64

-- | The payload stored in a <tt>NaN</tt> value. Undefined if the argument
--   is not <tt>NaN</tt>.
nanPayload :: IEEE a => a -> Word64

-- | Return the minimum of two values; if one value is <tt>NaN</tt>, return
--   the other. Prefer the first if both values are <tt>NaN</tt>.
minNum :: RealFloat a => a -> a -> a

-- | Return the maximum of two values; if one value is <tt>NaN</tt>, return
--   the other. Prefer the first if both values are <tt>NaN</tt>.
maxNum :: RealFloat a => a -> a -> a

-- | Return the minimum of two values; if one value is <tt>NaN</tt>, return
--   it. Prefer the first if both values are <tt>NaN</tt>.
minNaN :: RealFloat a => a -> a -> a

-- | Return the maximum of two values; if one value is <tt>NaN</tt>, return
--   it. Prefer the first if both values are <tt>NaN</tt>.
maxNaN :: RealFloat a => a -> a -> a
instance Numeric.IEEE.IEEE GHC.Types.Float
instance Numeric.IEEE.IEEE Foreign.C.Types.CFloat
instance Numeric.IEEE.IEEE GHC.Types.Double
instance Numeric.IEEE.IEEE Foreign.C.Types.CDouble


-- | A type class for approximate and exact equalilty comparisons and
--   instances for common data types.
module Data.AEq

-- | Types with approximate and exact equality comparisons.
class Eq a => AEq a

-- | An exact equality comparison.
--   
--   For real <a>IEEE</a> types, two values are equivalent in the following
--   cases:
--   
--   <ul>
--   <li>both values are <tt>+0</tt>;</li>
--   <li>both values are <tt>-0</tt>;</li>
--   <li>both values are nonzero and equal to each other (according to
--   <a>==</a>);</li>
--   <li>both values are <tt>NaN</tt> with the same payload and sign.</li>
--   </ul>
--   
--   For complex <a>IEEE</a> types, two values are equivalent if their real
--   and imaginary parts are equivalent.
(===) :: AEq a => a -> a -> Bool

-- | An approximate equality comparison operator.
--   
--   For real <a>IEEE</a> types, two values are approximately equal in the
--   following cases:
--   
--   <ul>
--   <li>at least half of their significand bits agree;</li>
--   <li>both values are less than <a>epsilon</a>;</li>
--   <li>both values are <tt>NaN</tt>.</li>
--   </ul>
--   
--   For complex <a>IEEE</a> types, two values are approximately equal in
--   the followiing cases:
--   
--   <ul>
--   <li>their magnitudes are approximately equal and the angle between
--   them is less than <tt>32*<a>epsilon</a></tt>;</li>
--   <li>both magnitudes are less than <a>epsilon</a>;</li>
--   <li>both have a <tt>NaN</tt> real or imaginary part.</li>
--   </ul>
--   
--   Admitedly, the <tt>32</tt> is a bit of a hack. Future versions of the
--   library may switch to a more principled test of the angle.
(~==) :: AEq a => a -> a -> Bool
infix 4 ===
infix 4 ~==
instance Data.AEq.AEq GHC.Types.Float
instance Data.AEq.AEq GHC.Types.Double
instance Data.AEq.AEq (Data.Complex.Complex GHC.Types.Float)
instance Data.AEq.AEq (Data.Complex.Complex GHC.Types.Double)
instance Data.AEq.AEq Foreign.C.Types.CFloat
instance Data.AEq.AEq Foreign.C.Types.CDouble
instance Data.AEq.AEq (Data.Complex.Complex Foreign.C.Types.CFloat)
instance Data.AEq.AEq (Data.Complex.Complex Foreign.C.Types.CDouble)
instance Data.AEq.AEq GHC.Types.Bool
instance Data.AEq.AEq GHC.Types.Char
instance Data.AEq.AEq GHC.Types.Int
instance Data.AEq.AEq GHC.Int.Int8
instance Data.AEq.AEq GHC.Int.Int16
instance Data.AEq.AEq GHC.Int.Int32
instance Data.AEq.AEq GHC.Int.Int64
instance Data.AEq.AEq GHC.Integer.Type.Integer
instance Data.AEq.AEq GHC.Types.Ordering
instance Data.AEq.AEq GHC.Types.Word
instance Data.AEq.AEq GHC.Word.Word8
instance Data.AEq.AEq GHC.Word.Word16
instance Data.AEq.AEq GHC.Word.Word32
instance Data.AEq.AEq GHC.Word.Word64
instance Data.AEq.AEq ()
instance Data.AEq.AEq Foreign.Ptr.WordPtr
instance Data.AEq.AEq Foreign.Ptr.IntPtr
instance Data.AEq.AEq (GHC.Stable.StablePtr a)
instance Data.AEq.AEq (GHC.Ptr.Ptr a)
instance Data.AEq.AEq (GHC.Ptr.FunPtr a)
instance Data.AEq.AEq (GHC.ForeignPtr.ForeignPtr a)
instance Data.AEq.AEq Foreign.C.Types.CChar
instance Data.AEq.AEq Foreign.C.Types.CSChar
instance Data.AEq.AEq Foreign.C.Types.CUChar
instance Data.AEq.AEq Foreign.C.Types.CShort
instance Data.AEq.AEq Foreign.C.Types.CUShort
instance Data.AEq.AEq Foreign.C.Types.CInt
instance Data.AEq.AEq Foreign.C.Types.CUInt
instance Data.AEq.AEq Foreign.C.Types.CLong
instance Data.AEq.AEq Foreign.C.Types.CULong
instance Data.AEq.AEq Foreign.C.Types.CPtrdiff
instance Data.AEq.AEq Foreign.C.Types.CSize
instance Data.AEq.AEq Foreign.C.Types.CWchar
instance Data.AEq.AEq Foreign.C.Types.CSigAtomic
instance Data.AEq.AEq Foreign.C.Types.CLLong
instance Data.AEq.AEq Foreign.C.Types.CULLong
instance Data.AEq.AEq Foreign.C.Types.CIntPtr
instance Data.AEq.AEq Foreign.C.Types.CUIntPtr
instance Data.AEq.AEq Foreign.C.Types.CIntMax
instance Data.AEq.AEq Foreign.C.Types.CUIntMax
instance Data.AEq.AEq Foreign.C.Types.CClock
instance Data.AEq.AEq Foreign.C.Types.CTime
instance Data.AEq.AEq a => Data.AEq.AEq [a]
instance Data.AEq.AEq a => Data.AEq.AEq (GHC.Maybe.Maybe a)
instance (Data.AEq.AEq a, Data.AEq.AEq b) => Data.AEq.AEq (Data.Either.Either a b)
instance (Data.AEq.AEq a, Data.AEq.AEq b) => Data.AEq.AEq (a, b)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c) => Data.AEq.AEq (a, b, c)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d) => Data.AEq.AEq (a, b, c, d)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e) => Data.AEq.AEq (a, b, c, d, e)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f) => Data.AEq.AEq (a, b, c, d, e, f)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g) => Data.AEq.AEq (a, b, c, d, e, f, g)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h) => Data.AEq.AEq (a, b, c, d, e, f, g, h)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i, Data.AEq.AEq j) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i, j)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i, Data.AEq.AEq j, Data.AEq.AEq k) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i, j, k)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i, Data.AEq.AEq j, Data.AEq.AEq k, Data.AEq.AEq l) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i, Data.AEq.AEq j, Data.AEq.AEq k, Data.AEq.AEq l, Data.AEq.AEq m) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i, Data.AEq.AEq j, Data.AEq.AEq k, Data.AEq.AEq l, Data.AEq.AEq m, Data.AEq.AEq n) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Data.AEq.AEq a, Data.AEq.AEq b, Data.AEq.AEq c, Data.AEq.AEq d, Data.AEq.AEq e, Data.AEq.AEq f, Data.AEq.AEq g, Data.AEq.AEq h, Data.AEq.AEq i, Data.AEq.AEq j, Data.AEq.AEq k, Data.AEq.AEq l, Data.AEq.AEq m, Data.AEq.AEq n, Data.AEq.AEq o) => Data.AEq.AEq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
