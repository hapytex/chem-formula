-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Statically checked physical dimensions,
--   using Type Families and Data Kinds.
--   
--   Dimensional is a library providing data types for performing
--   arithmetic with physical quantities and units. Information about the
--   physical dimensions of the quantities and units is embedded in their
--   types and the validity of operations is verified by the type checker
--   at compile time. The boxing and unboxing of numerical values as
--   quantities is done by multiplication and division with units. The
--   library is designed to, as far as is practical, enforce/encourage best
--   practices of unit usage. Version 1 of the dimensional package differs
--   from earlier version in that the dimension tracking is implemented
--   using Closed Type Families and Data Kinds rather than functional
--   dependencies. This enables a number of features, including improved
--   support for unit names and quantities with statically-unknown
--   dimensions. Requires GHC 8.0 or later.
@package dimensional
@version 1.3


-- | This module defines physical dimensions expressed in terms of the SI
--   base dimensions, including arithmetic.
module Numeric.Units.Dimensional.Dimensions.TermLevel

-- | A physical dimension, encoded as 7 integers, representing a
--   factorization of the dimension into the 7 SI base dimensions. By
--   convention they are stored in the same order as in the
--   <a>Dimension</a> data kind.
data Dimension'
Dim' :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> Dimension'

-- | Dimensional values inhabit this class, which allows access to a
--   term-level representation of their dimension.
class HasDynamicDimension a => HasDimension a

-- | Obtains a term-level representation of a value's dimension.
dimension :: HasDimension a => a -> Dimension'

-- | Dimensional values, or those that are only possibly dimensional,
--   inhabit this class, which allows access to a term-level representation
--   of their dimension.
class HasDynamicDimension a

-- | Gets the 'DynamicDimension of a dynamic dimensional value, which may
--   be <a>NoDimension</a> if it does not represent a dimensional value of
--   any <tt>Dimension</tt>.
--   
--   A default implementation is available for types that are also in the
--   <a>HasDimension</a> typeclass.
dynamicDimension :: HasDynamicDimension a => a -> DynamicDimension

-- | Gets the 'DynamicDimension of a dynamic dimensional value, which may
--   be <a>NoDimension</a> if it does not represent a dimensional value of
--   any <tt>Dimension</tt>.
--   
--   A default implementation is available for types that are also in the
--   <a>HasDimension</a> typeclass.
dynamicDimension :: (HasDynamicDimension a, HasDimension a) => a -> DynamicDimension

-- | The dimension of a dynamic value, which may not have any dimension at
--   all.
data DynamicDimension

-- | The value has no valid dimension.
NoDimension :: DynamicDimension

-- | The value has the given dimension.
SomeDimension :: Dimension' -> DynamicDimension

-- | The value may be interpreted as having any dimension.
AnyDimension :: DynamicDimension

-- | Forms the product of two dimensions.
(*) :: Dimension' -> Dimension' -> Dimension'
infixl 7 *

-- | Forms the quotient of two dimensions.
(/) :: Dimension' -> Dimension' -> Dimension'
infixl 7 /

-- | Raises a dimension to an integer power.
(^) :: Dimension' -> Int -> Dimension'
infixr 8 ^

-- | Forms the reciprocal of a dimension.
recip :: Dimension' -> Dimension'

-- | Takes the nth root of a dimension, if it exists.
--   
--   n must not be zero.
--   
--   <pre>
--   nroot (negate n) d == nroot n (recip d)
--   </pre>
nroot :: Int -> Dimension' -> Maybe Dimension'

-- | Takes the square root of a dimension, if it exists.
--   
--   <pre>
--   sqrt d == nroot 2 d
--   </pre>
sqrt :: Dimension' -> Maybe Dimension'

-- | Takes the cube root of a dimension, if it exists.
--   
--   <pre>
--   cbrt d == nroot 3 d
--   </pre>
cbrt :: Dimension' -> Maybe Dimension'

-- | The dimension of dimensionless values.
dOne :: Dimension'
dLength :: Dimension'
dMass :: Dimension'
dTime :: Dimension'
dElectricCurrent :: Dimension'
dThermodynamicTemperature :: Dimension'
dAmountOfSubstance :: Dimension'
dLuminousIntensity :: Dimension'

-- | Converts a dimension to a list of 7 integers, representing the
--   exponent associated with each of the 7 SI base dimensions in the
--   standard order.
asList :: Dimension' -> [Int]

-- | Combines two <a>DynamicDimension</a>s, determining the
--   <a>DynamicDimension</a> of a quantity that must match both inputs.
--   
--   This is the lattice meet operation for <a>DynamicDimension</a>.
matchDimensions :: DynamicDimension -> DynamicDimension -> DynamicDimension

-- | Determines if a value that has a <a>DynamicDimension</a> is compatible
--   with a specified <a>Dimension'</a>.
isCompatibleWith :: HasDynamicDimension a => a -> Dimension' -> Bool

-- | Determines if a value that has a <a>DynamicDimension</a> in fact has
--   any valid dimension at all.
hasSomeDimension :: HasDynamicDimension a => a -> Bool
instance GHC.Generics.Generic Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance Data.Data.Data Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance GHC.Show.Show Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance GHC.Classes.Ord Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance GHC.Classes.Eq Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance GHC.Generics.Generic Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance Data.Data.Data Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance GHC.Classes.Ord Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance GHC.Classes.Eq Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance GHC.Show.Show Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDynamicDimension Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDynamicDimension Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDimension Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance Control.DeepSeq.NFData Numeric.Units.Dimensional.Dimensions.TermLevel.DynamicDimension
instance Control.DeepSeq.NFData Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance GHC.Base.Semigroup Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'
instance GHC.Base.Monoid Numeric.Units.Dimensional.Dimensions.TermLevel.Dimension'


-- | This module defines type-level physical dimensions expressed in terms
--   of the SI base dimensions using <a>NumType</a> for type-level
--   integers.
--   
--   Type-level arithmetic, synonyms for the base dimensions, and
--   conversion to the term-level are included.
module Numeric.Units.Dimensional.Dimensions.TypeLevel

-- | Represents a physical dimension in the basis of the 7 SI base
--   dimensions, where the respective dimensions are represented by type
--   variables using the following convention:
--   
--   <ul>
--   <li>l: Length</li>
--   <li>m: Mass</li>
--   <li>t: Time</li>
--   <li>i: Electric current</li>
--   <li>th: Thermodynamic temperature</li>
--   <li>n: Amount of substance</li>
--   <li>j: Luminous intensity</li>
--   </ul>
--   
--   For the equivalent term-level representation, see <a>Dimension'</a>
data Dimension
Dim :: TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> Dimension

-- | Multiplication of dimensions corresponds to adding of the base
--   dimensions' exponents.
type family (a :: Dimension) * (b :: Dimension)
infixl 7 *

-- | Division of dimensions corresponds to subtraction of the base
--   dimensions' exponents.
type family (a :: Dimension) / (d :: Dimension)
infixl 7 /

-- | Powers of dimensions corresponds to multiplication of the base
--   dimensions' exponents by the exponent.
--   
--   We limit ourselves to integer powers of Dimensionals as fractional
--   powers make little physical sense.
type family (d :: Dimension) ^ (x :: TypeInt)
infixr 8 ^

-- | The reciprocal of a dimension is defined as the result of dividing
--   <a>DOne</a> by it, or of negating each of the base dimensions'
--   exponents.
type Recip (d :: Dimension) = DOne / d

-- | Roots of dimensions corresponds to division of the base dimensions'
--   exponents by the order of the root.
type family NRoot (d :: Dimension) (x :: TypeInt)

-- | Square root is a special case of <a>NRoot</a> with order 2.
type Sqrt d = NRoot d 'Pos2

-- | Cube root is a special case of <a>NRoot</a> with order 3.
type Cbrt d = NRoot d 'Pos3

-- | The type-level dimension of dimensionless values.
type DOne = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DLength = 'Dim 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DMass = 'Dim 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DTime = 'Dim 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero
type DElectricCurrent = 'Dim 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero
type DThermodynamicTemperature = 'Dim 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero
type DAmountOfSubstance = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero
type DLuminousIntensity = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1

-- | A KnownDimension is one for which we can construct a term-level
--   representation. Each validly constructed type of kind <a>Dimension</a>
--   has a <a>KnownDimension</a> instance.
--   
--   While <a>KnownDimension</a> is a constraint synonym, the presence of
--   <tt><a>KnownDimension</a> d</tt> in a context allows use of
--   <tt><a>dimension</a> :: <a>Proxy</a> d -&gt; <a>Dimension'</a></tt>.
type KnownDimension (d :: Dimension) = HasDimension (Proxy d)
instance (Numeric.NumType.DK.Integers.KnownTypeInt l, Numeric.NumType.DK.Integers.KnownTypeInt m, Numeric.NumType.DK.Integers.KnownTypeInt t, Numeric.NumType.DK.Integers.KnownTypeInt i, Numeric.NumType.DK.Integers.KnownTypeInt th, Numeric.NumType.DK.Integers.KnownTypeInt n, Numeric.NumType.DK.Integers.KnownTypeInt j) => Numeric.Units.Dimensional.Dimensions.TermLevel.HasDynamicDimension (Data.Proxy.Proxy ('Numeric.Units.Dimensional.Dimensions.TypeLevel.Dim l m t i th n j))
instance (Numeric.NumType.DK.Integers.KnownTypeInt l, Numeric.NumType.DK.Integers.KnownTypeInt m, Numeric.NumType.DK.Integers.KnownTypeInt t, Numeric.NumType.DK.Integers.KnownTypeInt i, Numeric.NumType.DK.Integers.KnownTypeInt th, Numeric.NumType.DK.Integers.KnownTypeInt n, Numeric.NumType.DK.Integers.KnownTypeInt j) => Numeric.Units.Dimensional.Dimensions.TermLevel.HasDimension (Data.Proxy.Proxy ('Numeric.Units.Dimensional.Dimensions.TypeLevel.Dim l m t i th n j))


-- | Provides both term-level and type-level representations for physical
--   dimensions in a single import for convenience.
--   
--   Presuming that users intend to work primarily with type level
--   dimensions, this module hides arithmetic operators over term level
--   dimensions and aliases for the base term-level dimensions to avoid
--   namespace pollution. These features are available directly from
--   <a>Numeric.Units.Dimensional.Dimensions.TermLevel</a> if desired.
module Numeric.Units.Dimensional.Dimensions

-- | Dimensional values inhabit this class, which allows access to a
--   term-level representation of their dimension.
class HasDynamicDimension a => HasDimension a

-- | Obtains a term-level representation of a value's dimension.
dimension :: HasDimension a => a -> Dimension'

-- | Dimensional values, or those that are only possibly dimensional,
--   inhabit this class, which allows access to a term-level representation
--   of their dimension.
class HasDynamicDimension a

-- | Gets the 'DynamicDimension of a dynamic dimensional value, which may
--   be <a>NoDimension</a> if it does not represent a dimensional value of
--   any <tt>Dimension</tt>.
--   
--   A default implementation is available for types that are also in the
--   <a>HasDimension</a> typeclass.
dynamicDimension :: HasDynamicDimension a => a -> DynamicDimension

-- | Gets the 'DynamicDimension of a dynamic dimensional value, which may
--   be <a>NoDimension</a> if it does not represent a dimensional value of
--   any <tt>Dimension</tt>.
--   
--   A default implementation is available for types that are also in the
--   <a>HasDimension</a> typeclass.
dynamicDimension :: (HasDynamicDimension a, HasDimension a) => a -> DynamicDimension

-- | The dimension of a dynamic value, which may not have any dimension at
--   all.
data DynamicDimension

-- | The value has no valid dimension.
NoDimension :: DynamicDimension

-- | The value has the given dimension.
SomeDimension :: Dimension' -> DynamicDimension

-- | The value may be interpreted as having any dimension.
AnyDimension :: DynamicDimension

-- | A physical dimension, encoded as 7 integers, representing a
--   factorization of the dimension into the 7 SI base dimensions. By
--   convention they are stored in the same order as in the
--   <a>Dimension</a> data kind.
data Dimension'
Dim' :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> Dimension'

-- | Combines two <a>DynamicDimension</a>s, determining the
--   <a>DynamicDimension</a> of a quantity that must match both inputs.
--   
--   This is the lattice meet operation for <a>DynamicDimension</a>.
matchDimensions :: DynamicDimension -> DynamicDimension -> DynamicDimension

-- | Determines if a value that has a <a>DynamicDimension</a> is compatible
--   with a specified <a>Dimension'</a>.
isCompatibleWith :: HasDynamicDimension a => a -> Dimension' -> Bool

-- | Determines if a value that has a <a>DynamicDimension</a> in fact has
--   any valid dimension at all.
hasSomeDimension :: HasDynamicDimension a => a -> Bool

-- | The dimension of dimensionless values.
dOne :: Dimension'

-- | Converts a dimension to a list of 7 integers, representing the
--   exponent associated with each of the 7 SI base dimensions in the
--   standard order.
asList :: Dimension' -> [Int]

module Numeric.Units.Dimensional.UnitNames.InterchangeNames

-- | Represents the authority which issued an interchange name for a unit.
data InterchangeNameAuthority

-- | The interchange name originated with the Unified Code for Units of
--   Measure.
UCUM :: InterchangeNameAuthority

-- | The interchange name originated with the dimensional library.
DimensionalLibrary :: InterchangeNameAuthority

-- | The interchange name originated with a user of the dimensional
--   library.
Custom :: InterchangeNameAuthority
data InterchangeName
InterchangeName :: String -> InterchangeNameAuthority -> Bool -> InterchangeName
[name] :: InterchangeName -> String
[authority] :: InterchangeName -> InterchangeNameAuthority
[isAtomic] :: InterchangeName -> Bool

-- | Determines the authority which issued the interchange name of a unit
--   or unit name. For composite units, this is the least-authoritative
--   interchange name of any constituent name.
--   
--   Note that the least-authoritative authority is the one sorted as
--   greatest by the <a>Ord</a> instance of
--   <a>InterchangeNameAuthority</a>.
class HasInterchangeName a
interchangeName :: HasInterchangeName a => a -> InterchangeName
instance GHC.Generics.Generic Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance Data.Data.Data Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance GHC.Classes.Ord Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance GHC.Classes.Eq Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance GHC.Generics.Generic Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeNameAuthority
instance Data.Data.Data Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeNameAuthority
instance GHC.Show.Show Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeNameAuthority
instance GHC.Classes.Ord Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeNameAuthority
instance GHC.Classes.Eq Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeNameAuthority
instance Numeric.Units.Dimensional.UnitNames.InterchangeNames.HasInterchangeName Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance Control.DeepSeq.NFData Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance GHC.Show.Show Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeName
instance Control.DeepSeq.NFData Numeric.Units.Dimensional.UnitNames.InterchangeNames.InterchangeNameAuthority


-- | Provides a type level representation of <a>Variant</a>s of dimensional
--   values, which may be quantities or units.
module Numeric.Units.Dimensional.Variants

-- | The kind of variants of dimensional values.
data Variant

-- | The value is a quantity, stored as an <tt>ExactPi</tt> multiple of its
--   value in its dimension's SI coherent unit.
DQuantity :: ExactPi' -> Variant

-- | The value is a unit, possibly a <a>Metric</a> unit.
DUnit :: Metricality -> Variant

-- | Encodes whether a unit is a metric unit, that is, whether it can be
--   combined with a metric prefix to form a related unit.
data Metricality

-- | Capable of receiving a metric prefix.
Metric :: Metricality

-- | Incapable of receiving a metric prefix.
NonMetric :: Metricality

-- | Forms the product of two <a>Variant</a>s.
--   
--   The product of units is a non-metric unit.
--   
--   The product of quantities is a quantity.
type family (v1 :: Variant) * (v2 :: Variant) :: Variant
infixl 7 *
type family (v1 :: Variant) / (v2 :: Variant) :: Variant

-- | Weakens a <a>Variant</a> by forgetting possibly uninteresting
--   type-level information.
type family Weaken (v :: Variant) :: Variant

-- | Two <a>Variant</a>s are compatible when dimensional values of the
--   first may be converted into the second merely by changing the
--   representation of their values.
type CompatibleVariants v1 v2 = ('True ~ AreCompatible v1 v2)
instance GHC.Generics.Generic Numeric.Units.Dimensional.Variants.Variant
instance GHC.Generics.Generic Numeric.Units.Dimensional.Variants.Metricality
instance Data.Data.Data Numeric.Units.Dimensional.Variants.Metricality
instance GHC.Classes.Ord Numeric.Units.Dimensional.Variants.Metricality
instance GHC.Classes.Eq Numeric.Units.Dimensional.Variants.Metricality
instance Control.DeepSeq.NFData Numeric.Units.Dimensional.Variants.Metricality


-- | This module provides types and functions for manipulating unit names.
--   
--   Please note that the details of the name representation may be less
--   stable than the other APIs provided by this package, as new features
--   using them are still being developed.
module Numeric.Units.Dimensional.UnitNames

-- | The name of a unit.
data UnitName (m :: Metricality)

-- | Represents the name of an atomic unit or prefix.
data NameAtom (m :: NameAtomType)
data Prefix

-- | The name of a metric prefix.
type PrefixName = NameAtom 'PrefixAtom

-- | Encodes whether a unit is a metric unit, that is, whether it can be
--   combined with a metric prefix to form a related unit.
data Metricality

-- | Capable of receiving a metric prefix.
Metric :: Metricality

-- | Incapable of receiving a metric prefix.
NonMetric :: Metricality

-- | Constructs an atomic name for a custom unit.
atom :: String -> String -> String -> UnitName 'NonMetric

-- | Forms a <a>UnitName</a> from a <a>Metric</a> name by applying a metric
--   prefix.
applyPrefix :: Prefix -> UnitName 'Metric -> UnitName 'NonMetric

-- | Form a <a>UnitName</a> by taking the product of two others.
(*) :: UnitName m1 -> UnitName m2 -> UnitName 'NonMetric
infixl 7 *

-- | Form a <a>UnitName</a> by dividing one by another.
(/) :: UnitName m1 -> UnitName m2 -> UnitName 'NonMetric
infixl 7 /

-- | Form a <a>UnitName</a> by raising a name to an integer power.
(^) :: UnitName m -> Int -> UnitName 'NonMetric
infixr 8 ^

-- | Forms the product of a list of <a>UnitName</a>s.
--   
--   If you wish to form a heterogenous product of <a>Metric</a> and
--   <a>NonMetric</a> units you should apply <a>weaken</a> to the
--   <a>Metric</a> ones.
product :: Foldable f => f (UnitName 'NonMetric) -> UnitName 'NonMetric
reduce :: UnitName m -> UnitName m

-- | Constructs a <a>UnitName</a> by applying a grouping operation to
--   another <a>UnitName</a>, which may be useful to express precedence.
grouped :: UnitName m -> UnitName 'NonMetric

-- | The name of the base unit associated with a specified dimension.
baseUnitName :: Dimension' -> UnitName 'NonMetric

-- | A list of all <a>Prefix</a>es defined by the SI.
siPrefixes :: [Prefix]

-- | The name of the unit of dimensionless values.
nOne :: UnitName 'NonMetric

-- | The name of a metric prefix.
prefixName :: Prefix -> PrefixName

-- | The scale factor denoted by a metric prefix.
scaleFactor :: Prefix -> Rational

-- | The type of a unit name transformation that may be associated with an
--   operation that takes a single unit as input.
type UnitNameTransformer = (forall m. UnitName m -> UnitName 'NonMetric)

-- | The type of a unit name transformation that may be associated with an
--   operation that takes two units as input.
type UnitNameTransformer2 = (forall m1 m2. UnitName m1 -> UnitName m2 -> UnitName 'NonMetric)

-- | Convert a <a>UnitName</a> which may or may not be <a>Metric</a> to one
--   which is certainly <a>NonMetric</a>.
weaken :: UnitName m -> UnitName 'NonMetric

-- | Attempt to convert a <a>UnitName</a> which may or may not be
--   <a>Metric</a> to one which is certainly <a>Metric</a>.
strengthen :: UnitName m -> Maybe (UnitName 'Metric)

-- | Convert a <a>UnitName</a> of one <a>Metricality</a> into a name of
--   another metricality by strengthening or weakening if neccessary.
--   Because it may not be possible to strengthen, the result is returned
--   in a <a>Maybe</a> wrapper.
relax :: forall m1 m2. (Typeable m1, Typeable m2) => UnitName m1 -> Maybe (UnitName m2)

-- | The full name of the unit in international English
name_en :: NameAtom m -> String

-- | The abbreviated name of the unit in international English
abbreviation_en :: NameAtom m -> String
asAtomic :: UnitName m -> Maybe (NameAtom ('UnitAtom m))


-- | Re-exports the raw <a>Quantity</a> constructor from the
--   Numeric.Units.Dimensional.Internal module, along with <a>coerce</a>,
--   for convenience in converting between raw representations and
--   dimensional values.
--   
--   Note that use of these constructs requires the user to verify the
--   dimensional safety of the conversion, because the coercion doesn't
--   explicitly mention the unit of the representation. Note also that the
--   <a>Quantity</a> constructor constructs a <a>SQuantity</a> which may
--   have a scale factor other than <a>One</a>.
--   
--   Note that the haddock documentation doesn't mention the
--   <a>Quantity</a> constructor because it is a part of the
--   <a>Dimensional</a> associated data family, but it is exported by this
--   module.
module Numeric.Units.Dimensional.Coercion

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | A dimensional value, either a <a>Quantity</a> or a <a>Unit</a>,
--   parameterized by its <a>Dimension</a> and representation.
data family Dimensional v :: Dimension -> Type -> Type

-- | Unwraps a possibly-scaled <a>SQuantity</a>, yielding its underlying
--   representation.
--   
--   This is a type-restricted version of <a>coerce</a>.
unQuantity :: SQuantity s d a -> a


-- | <h1>Summary</h1>
--   
--   In this module we provide data types for performing arithmetic with
--   physical quantities and units. Information about the physical
--   dimensions of the quantities/units is embedded in their types and the
--   validity of operations is verified by the type checker at compile
--   time. The boxing and unboxing of numerical values as quantities is
--   done by multiplication and division of units, of which an incomplete
--   set is provided.
--   
--   We limit ourselves to "Newtonian" physics. We do not attempt to
--   accommodate relativistic physics in which e.g. addition of length and
--   time would be valid.
--   
--   As far as possible and/or practical the conventions and guidelines of
--   NIST's "Guide for the Use of the International System of Units (SI)"
--   <a>[1]</a> are followed. Occasionally we will reference specific
--   sections from the guide and deviations will be explained.
--   
--   <h2>Disclaimer</h2>
--   
--   Merely an engineer, the author doubtlessly uses a language and
--   notation that makes mathematicians and physicist cringe. He does not
--   mind constructive criticism (or pull requests).
--   
--   The sets of functions and units defined herein are incomplete and
--   reflect only the author's needs to date. Again, patches are welcome.
--   
--   <h1>Usage</h1>
--   
--   <h2>Preliminaries</h2>
--   
--   This module requires GHC 8 or later. We utilize Data Kinds, TypeNats,
--   Closed Type Families, etc. Clients of the module are generally not
--   required to use these extensions.
--   
--   Clients probably will want to use the NegativeLiterals extension.
--   
--   <h2>Examples</h2>
--   
--   We have defined operators and units that allow us to define and work
--   with physical quantities. A physical quantity is defined by
--   multiplying a number with a unit (the type signature is optional).
--   
--   <pre>
--   v :: Velocity Prelude.Double
--   v = 90 *~ (kilo meter / hour)
--   </pre>
--   
--   It follows naturally that the numerical value of a quantity is
--   obtained by division by a unit.
--   
--   <pre>
--   numval :: Prelude.Double
--   numval = v /~ (meter / second)
--   </pre>
--   
--   The notion of a quantity as the product of a numerical value and a
--   unit is supported by 7.1 "Value and numerical value of a quantity" of
--   <a>[1]</a>. While the above syntax is fairly natural it is unfortunate
--   that it must violate a number of the guidelines in <a>[1]</a>, in
--   particular 9.3 "Spelling unit names with prefixes", 9.4 "Spelling unit
--   names obtained by multiplication", 9.5 "Spelling unit names obtained
--   by division".
--   
--   As a more elaborate example of how to use the module we define a
--   function for calculating the escape velocity of a celestial body
--   <a>[2]</a>.
--   
--   <pre>
--   escapeVelocity :: (Floating a) =&gt; Mass a -&gt; Length a -&gt; Velocity a
--   escapeVelocity m r = sqrt (two * g * m / r)
--     where
--         two = 2 *~ one
--         g = 6.6720e-11 *~ (newton * meter ^ pos2 / kilo gram ^ pos2)
--   </pre>
--   
--   For completeness we should also show an example of the error messages
--   we will get from GHC when performing invalid arithmetic. In the best
--   case GHC will be able to use the type synonyms we have defined in its
--   error messages.
--   
--   <pre>
--   let x = 1 *~ meter + 1 *~ second
--   
--   Couldn't match type 'Numeric.NumType.DK.Integers.Zero
--                  with 'Numeric.NumType.DK.Integers.Pos1
--   Expected type: Unit 'Metric DLength a
--     Actual type: Unit 'Metric DTime a
--   In the second argument of `(*~)', namely `second'
--   In the second argument of `(+)', namely `1 *~ second'
--   </pre>
--   
--   In other cases the error messages aren't very friendly.
--   
--   <pre>
--   let x = 1 *~ meter / (1 *~ second) + 1 *~ kilo gram
--   
--   Couldn't match type 'Numeric.NumType.DK.Integers.Zero
--                  with 'Numeric.NumType.DK.Integers.Neg1
--   Expected type: Quantity DMass a
--     Actual type: Dimensional
--                    ('DQuantity V.* 'DQuantity) (DLength / DTime) a
--   In the first argument of `(+)', namely `1 *~ meter / (1 *~ second)'
--   In the expression: 1 *~ meter / (1 *~ second) + 1 *~ kilo gram
--   In an equation for `x':
--         x = 1 *~ meter / (1 *~ second) + 1 *~ kilo gram
--   </pre>
--   
--   It is the author's experience that the usefulness of the compiler
--   error messages is more often than not limited to pinpointing the
--   location of errors.
--   
--   <h1>Notes</h1>
--   
--   <h2>Future work</h2>
--   
--   While there is an insane amount of units in use around the world it is
--   reasonable to provide those in relatively widespread use. Units
--   outside of SI will most likely be added on an as-needed basis.
--   
--   Additional physics models could be implemented. See <a>[3]</a> for
--   ideas.
--   
--   <h2>Related work</h2>
--   
--   Henning Thielemann numeric prelude has a physical units library,
--   however, checking of dimensions is dynamic rather than static. Aaron
--   Denney has created a toy example of statically checked physical
--   dimensions covering only length and time. HaskellWiki has pointers
--   <a>[4]</a> to these.
--   
--   Also see Samuel Hoffstaetter's blog post <a>[5]</a> which uses
--   techniques similar to this library.
--   
--   Libraries with similar functionality exist for other programming
--   languages and may serve as inspiration. The author has found the Java
--   library JScience <a>[6]</a> and the Fortress programming language
--   <a>[7]</a> particularly noteworthy.
--   
--   <h2>References</h2>
--   
--   <ol>
--   <li><a>http://physics.nist.gov/Pubs/SP811/</a></li>
--   <li><a>http://en.wikipedia.org/wiki/Escape_velocity</a></li>
--   
--   <li><a>http://jscience.org/api/org/jscience/physics/models/package-summary.html</a></li>
--   <li><a>http://www.haskell.org/haskellwiki/Physical_units</a></li>
--   
--   <li><a>http://liftm.wordpress.com/2007/06/03/scientificdimension-type-arithmetic-and-physical-units-in-haskell/</a></li>
--   <li><a>http://jscience.org/</a></li>
--   <li><a>http://research.sun.com/projects/plrg/fortress.pdf</a></li>
--   </ol>
module Numeric.Units.Dimensional

-- | A dimensional value, either a <a>Quantity</a> or a <a>Unit</a>,
--   parameterized by its <a>Dimension</a> and representation.
data family Dimensional v :: Dimension -> Type -> Type

-- | A unit of measurement.
type Unit (m :: Metricality) = Dimensional ('DUnit m)

-- | A dimensional quantity.
type Quantity = SQuantity One

-- | Encodes whether a unit is a metric unit, that is, whether it can be
--   combined with a metric prefix to form a related unit.
data Metricality

-- | Capable of receiving a metric prefix.
Metric :: Metricality

-- | Incapable of receiving a metric prefix.
NonMetric :: Metricality

-- | Represents a physical dimension in the basis of the 7 SI base
--   dimensions, where the respective dimensions are represented by type
--   variables using the following convention:
--   
--   <ul>
--   <li>l: Length</li>
--   <li>m: Mass</li>
--   <li>t: Time</li>
--   <li>i: Electric current</li>
--   <li>th: Thermodynamic temperature</li>
--   <li>n: Amount of substance</li>
--   <li>j: Luminous intensity</li>
--   </ul>
--   
--   For the equivalent term-level representation, see <a>Dimension'</a>
data Dimension
Dim :: TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> Dimension

-- | Multiplication of dimensions corresponds to adding of the base
--   dimensions' exponents.
type family (a :: Dimension) * (b :: Dimension)
infixl 7 *

-- | Division of dimensions corresponds to subtraction of the base
--   dimensions' exponents.
type family (a :: Dimension) / (d :: Dimension)
infixl 7 /

-- | Powers of dimensions corresponds to multiplication of the base
--   dimensions' exponents by the exponent.
--   
--   We limit ourselves to integer powers of Dimensionals as fractional
--   powers make little physical sense.
type family (d :: Dimension) ^ (x :: TypeInt)
infixr 8 ^

-- | Roots of dimensions corresponds to division of the base dimensions'
--   exponents by the order of the root.
type family NRoot (d :: Dimension) (x :: TypeInt)

-- | Square root is a special case of <a>NRoot</a> with order 2.
type Sqrt d = NRoot d 'Pos2

-- | Cube root is a special case of <a>NRoot</a> with order 3.
type Cbrt d = NRoot d 'Pos3

-- | The reciprocal of a dimension is defined as the result of dividing
--   <a>DOne</a> by it, or of negating each of the base dimensions'
--   exponents.
type Recip (d :: Dimension) = DOne / d

-- | A physical dimension, encoded as 7 integers, representing a
--   factorization of the dimension into the 7 SI base dimensions. By
--   convention they are stored in the same order as in the
--   <a>Dimension</a> data kind.
data Dimension'
Dim' :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> Dimension'

-- | Dimensional values inhabit this class, which allows access to a
--   term-level representation of their dimension.
class HasDynamicDimension a => HasDimension a

-- | Obtains a term-level representation of a value's dimension.
dimension :: HasDimension a => a -> Dimension'

-- | A KnownDimension is one for which we can construct a term-level
--   representation. Each validly constructed type of kind <a>Dimension</a>
--   has a <a>KnownDimension</a> instance.
--   
--   While <a>KnownDimension</a> is a constraint synonym, the presence of
--   <tt><a>KnownDimension</a> d</tt> in a context allows use of
--   <tt><a>dimension</a> :: <a>Proxy</a> d -&gt; <a>Dimension'</a></tt>.
type KnownDimension (d :: Dimension) = HasDimension (Proxy d)

-- | Forms a <a>Quantity</a> by multipliying a number and a unit.
(*~) :: Num a => a -> Unit m d a -> Quantity d a
infixl 7 *~

-- | Divides a <a>Quantity</a> by a <a>Unit</a> of the same physical
--   dimension, obtaining the numerical value of the quantity expressed in
--   that unit.
(/~) :: Fractional a => Quantity d a -> Unit m d a -> a
infixl 7 /~

-- | Raises a <a>Quantity</a> or <a>Unit</a> to an integer power.
--   
--   Because the power chosen impacts the <a>Dimension</a> of the result,
--   it is necessary to supply a type-level representation of the exponent
--   in the form of a <a>Proxy</a> to some <tt>TypeInt</tt>. Convenience
--   values <tt>pos1</tt>, <a>pos2</a>, <tt>neg1</tt>, ... are supplied by
--   the <a>Numeric.NumType.DK.Integers</a> module. The most commonly used
--   ones are also reexported by <a>Numeric.Units.Dimensional.Prelude</a>.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <tt>NotPrefixable</tt>.
(^) :: (Fractional a, KnownTypeInt i, KnownVariant v, KnownVariant (Weaken v)) => Dimensional v d1 a -> Proxy i -> Dimensional (Weaken v) (d1 ^ i) a
infixr 8 ^

-- | Computes the nth root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application of this operator
--   where the result would have a fractional dimension or where n is zero.
--   
--   Because the root chosen impacts the <a>Dimension</a> of the result, it
--   is necessary to supply a type-level representation of the root in the
--   form of a <a>Proxy</a> to some <tt>TypeInt</tt>. Convenience values
--   <tt>pos1</tt>, <a>pos2</a>, <tt>neg1</tt>, ... are supplied by the
--   <a>Numeric.NumType.DK.Integers</a> module. The most commonly used ones
--   are also reexported by <a>Numeric.Units.Dimensional.Prelude</a>.
--   
--   Also available in prefix form, see <a>nroot</a>.
(^/) :: (KnownTypeInt n, Floating a) => Quantity d a -> Proxy n -> Quantity (NRoot d n) a
infixr 8 ^/

-- | Raises a dimensionless quantity to a dimensionless power.
(**) :: Floating a => Dimensionless a -> Dimensionless a -> Dimensionless a
infixr 8 **

-- | Multiplies two <a>Quantity</a>s or two <a>Unit</a>s.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <a>NonMetric</a>.
(*) :: (KnownVariant v1, KnownVariant v2, KnownVariant (v1 * v2), Num a) => Dimensional v1 d1 a -> Dimensional v2 d2 a -> Dimensional (v1 * v2) (d1 * d2) a
infixl 7 *

-- | Divides one <a>Quantity</a> by another or one <a>Unit</a> by another.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <tt>NotPrefixable</tt>.
(/) :: (KnownVariant v1, KnownVariant v2, KnownVariant (v1 / v2), Fractional a) => Dimensional v1 d1 a -> Dimensional v2 d2 a -> Dimensional (v1 / v2) (d1 / d2) a
infixl 7 /

-- | Adds two <a>Quantity</a>s.
(+) :: Num a => Quantity d a -> Quantity d a -> Quantity d a
infixl 6 +

-- | Subtracts one <a>Quantity</a> from another.
(-) :: Num a => Quantity d a -> Quantity d a -> Quantity d a
infixl 6 -

-- | Negates the value of a <a>Quantity</a>.
negate :: Num a => Quantity d a -> Quantity d a

-- | Takes the absolute value of a <a>Quantity</a>.
abs :: Num a => Quantity d a -> Quantity d a

-- | Takes the sign of a <a>Quantity</a>. The functions <a>abs</a> and
--   <a>signum</a> satisy the law that:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   The sign is either <tt>negate _1</tt> (negative), <tt>_0</tt> (zero),
--   or <tt>_1</tt> (positive).
signum :: Num a => Quantity d a -> Dimensionless a

-- | Forms the reciprocal of a <a>Quantity</a>, which has the reciprocal
--   dimension.
--   
--   <pre>
--   &gt;&gt;&gt; recip $ 47 *~ hertz
--   2.127659574468085e-2 s
--   </pre>
recip :: Fractional a => Quantity d a -> Quantity (Recip d) a

-- | Computes the nth root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application of this operator
--   where the result would have a fractional dimension or where n is zero.
--   
--   Because the root chosen impacts the <a>Dimension</a> of the result, it
--   is necessary to supply a type-level representation of the root in the
--   form of a <a>Proxy</a> to some <tt>TypeInt</tt>. Convenience values
--   <tt>pos1</tt>, <a>pos2</a>, <tt>neg1</tt>, ... are supplied by the
--   <a>Numeric.NumType.DK.Integers</a> module. The most commonly used ones
--   are also reexported by <a>Numeric.Units.Dimensional.Prelude</a>.
--   
--   n must not be zero. Negative roots are defined such that <tt>nroot
--   (Proxy :: Proxy (Negate n)) x == nroot (Proxy :: Proxy n) (recip
--   x)</tt>.
--   
--   Also available in operator form, see <a>^/</a>.
nroot :: (KnownTypeInt n, Floating a) => Proxy n -> Quantity d a -> Quantity (NRoot d n) a

-- | Computes the square root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application where the
--   supplied quantity does not have a square dimension.
--   
--   <pre>
--   (x :: Area Double) &gt;= _0 ==&gt; sqrt x == nroot pos2 x
--   </pre>
sqrt :: Floating a => Quantity d a -> Quantity (Sqrt d) a

-- | Computes the cube root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application where the
--   supplied quantity does not have a cubic dimension.
--   
--   <pre>
--   (x :: Volume Double) &gt;= _0 ==&gt; cbrt x == nroot pos3 x
--   </pre>
cbrt :: Floating a => Quantity d a -> Quantity (Cbrt d) a
exp :: Floating a => Dimensionless a -> Dimensionless a
log :: Floating a => Dimensionless a -> Dimensionless a

-- | Takes the logarithm of the second argument in the base of the first.
--   
--   <pre>
--   &gt;&gt;&gt; logBase _2 _8
--   3.0
--   </pre>
logBase :: Floating a => Dimensionless a -> Dimensionless a -> Dimensionless a
sin :: Floating a => Dimensionless a -> Dimensionless a
cos :: Floating a => Dimensionless a -> Dimensionless a
tan :: Floating a => Dimensionless a -> Dimensionless a
asin :: Floating a => Dimensionless a -> Dimensionless a
acos :: Floating a => Dimensionless a -> Dimensionless a
atan :: Floating a => Dimensionless a -> Dimensionless a
sinh :: Floating a => Dimensionless a -> Dimensionless a
cosh :: Floating a => Dimensionless a -> Dimensionless a
tanh :: Floating a => Dimensionless a -> Dimensionless a
asinh :: Floating a => Dimensionless a -> Dimensionless a
acosh :: Floating a => Dimensionless a -> Dimensionless a
atanh :: Floating a => Dimensionless a -> Dimensionless a

-- | The standard two argument arctangent function. Since it interprets its
--   two arguments in comparison with one another, the input may have any
--   dimension.
--   
--   <pre>
--   &gt;&gt;&gt; atan2 _0 _1
--   0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; atan2 _1 _0
--   1.5707963267948966
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; atan2 _0 (negate _1)
--   3.141592653589793
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; atan2 (negate _1) _0
--   -1.5707963267948966
--   </pre>
atan2 :: RealFloat a => Quantity d a -> Quantity d a -> Dimensionless a
log1p :: Floating a => Dimensionless a -> Dimensionless a
expm1 :: Floating a => Dimensionless a -> Dimensionless a
log1pexp :: Floating a => Dimensionless a -> Dimensionless a
log1mexp :: Floating a => Dimensionless a -> Dimensionless a

-- | Applies <a>*~</a> to all values in a functor.
(*~~) :: (Functor f, Num a) => f a -> Unit m d a -> f (Quantity d a)
infixl 7 *~~

-- | Applies <a>/~</a> to all values in a functor.
(/~~) :: forall f m d a. (Functor f, Fractional a) => f (Quantity d a) -> Unit m d a -> f a
infixl 7 /~~

-- | The sum of all elements in a foldable structure.
--   
--   <pre>
--   &gt;&gt;&gt; sum ([] :: [Mass Double])
--   0.0 kg
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [12.4 *~ meter, 1 *~ foot]
--   12.7048 m
--   </pre>
sum :: (Num a, Foldable f) => f (Quantity d a) -> Quantity d a

-- | The arithmetic mean of all elements in a foldable structure.
--   
--   <pre>
--   &gt;&gt;&gt; mean [pi, _7]
--   5.070796326794897
--   </pre>
mean :: (Fractional a, Foldable f) => f (Quantity d a) -> Quantity d a

-- | The product of all elements in a foldable structure.
--   
--   <pre>
--   &gt;&gt;&gt; product ([] :: [Dimensionless Double])
--   1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [pi, _4, 0.36 *~ one]
--   4.523893421169302
--   </pre>
product :: (Num a, Foldable f) => f (Dimensionless a) -> Dimensionless a

-- | The length of the foldable data structure as a <a>Dimensionless</a>.
--   This can be useful for purposes of e.g. calculating averages.
--   
--   <pre>
--   &gt;&gt;&gt; dimensionlessLength ["foo", "bar"]
--   2
--   </pre>
dimensionlessLength :: (Num a, Foldable f) => f b -> Dimensionless a

-- | Returns a list of quantities between given bounds.
--   
--   <pre>
--   n &lt;= 0 ==&gt; nFromTo (x :: Mass Double) (y :: Mass Double) n == [x, y]
--   </pre>
--   
--   <pre>
--   (x :: Length Double) &lt;= (y :: Length Double) ==&gt; all (\z -&gt; x &lt;= z &amp;&amp; z &lt;= y) (nFromTo x y n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nFromTo _0 _3 2
--   [0.0,1.0,2.0,3.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nFromTo _1 _0 7
--   [1.0,0.875,0.75,0.625,0.5,0.375,0.25,0.125,0.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nFromTo _0 _1 (-5)
--   [0.0,1.0]
--   </pre>
nFromTo :: (Fractional a, Integral b) => Quantity d a -> Quantity d a -> b -> [Quantity d a]

-- | The type-level dimension of dimensionless values.
type DOne = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DLength = 'Dim 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DMass = 'Dim 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DTime = 'Dim 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero
type DElectricCurrent = 'Dim 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero
type DThermodynamicTemperature = 'Dim 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero
type DAmountOfSubstance = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero
type DLuminousIntensity = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1
type Dimensionless = Quantity DOne
type Length = Quantity DLength
type Mass = Quantity DMass
type Time = Quantity DTime
type ElectricCurrent = Quantity DElectricCurrent
type ThermodynamicTemperature = Quantity DThermodynamicTemperature
type AmountOfSubstance = Quantity DAmountOfSubstance
type LuminousIntensity = Quantity DLuminousIntensity

-- | The constant for zero is polymorphic, allowing it to express zero
--   <a>Length</a> or <a>Capacitance</a> or <a>Velocity</a> etc, in
--   addition to the <a>Dimensionless</a> value zero.
_0 :: Num a => Quantity d a
_1 :: Num a => Dimensionless a
_2 :: Num a => Dimensionless a
_3 :: Num a => Dimensionless a
_4 :: Num a => Dimensionless a
_5 :: Num a => Dimensionless a
_6 :: Num a => Dimensionless a
_7 :: Num a => Dimensionless a
_8 :: Num a => Dimensionless a
_9 :: Num a => Dimensionless a
pi :: Floating a => Dimensionless a

-- | Twice <a>pi</a>.
--   
--   For background on <a>tau</a> see
--   <a>http://tauday.com/tau-manifesto</a> (but also feel free to review
--   <a>http://www.thepimanifesto.com)</a>.
tau :: Floating a => Dimensionless a

-- | A polymorphic <a>Unit</a> which can be used in place of the coherent
--   SI base unit of any dimension. This allows polymorphic quantity
--   creation and destruction without exposing the <a>Dimensional</a>
--   constructor.
siUnit :: forall d a. (KnownDimension d, Num a) => Unit 'NonMetric d a

-- | The unit <a>one</a> has dimension <a>DOne</a> and is the base unit of
--   dimensionless values.
--   
--   As detailed in 7.10 "Values of quantities expressed simply as numbers:
--   the unit one, symbol 1" of <a>[1]</a> the unit one generally does not
--   appear in expressions. However, for us it is necessary to use
--   <a>one</a> as we would any other unit to perform the "boxing" of
--   dimensionless values.
one :: Num a => Unit 'NonMetric DOne a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is
--   irrational or <a>Approximate</a>. See <a>mkUnitQ</a> for when it is
--   rational and <a>mkUnitZ</a> for when it is an integer.
--   
--   Note that supplying zero as a definining quantity is invalid, as the
--   library relies upon units forming a group under multiplication.
--   
--   Supplying negative defining quantities is allowed and handled
--   gracefully, but is discouraged on the grounds that it may be
--   unexpected by other readers.
mkUnitR :: Floating a => UnitName m -> ExactPi -> Unit m1 d a -> Unit m d a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is
--   rational. See <a>mkUnitZ</a> for when it is an integer and
--   <a>mkUnitR</a> for the general case.
--   
--   For more information see <a>mkUnitR</a>.
mkUnitQ :: Fractional a => UnitName m -> Rational -> Unit m1 d a -> Unit m d a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is an
--   integer. See <a>mkUnitQ</a> for when it is rational and <a>mkUnitR</a>
--   for the general case.
--   
--   For more information see <a>mkUnitR</a>.
mkUnitZ :: Num a => UnitName m -> Integer -> Unit m1 d a -> Unit m d a

-- | Extracts the <a>UnitName</a> of a <a>Unit</a>.
name :: Unit m d a -> UnitName m

-- | Extracts the exact value of a <a>Unit</a>, expressed in terms of the
--   SI coherent derived unit (see <a>siUnit</a>) of the same
--   <a>Dimension</a>.
--   
--   Note that the actual value may in some cases be approximate, for
--   example if the unit is defined by experiment.
exactValue :: Unit m d a -> ExactPi

-- | Discards potentially unwanted type level information about a
--   <a>Unit</a>.
weaken :: Unit m d a -> Unit 'NonMetric d a

-- | Attempts to convert a <a>Unit</a> which may or may not be
--   <a>Metric</a> to one which is certainly <a>Metric</a>.
strengthen :: Unit m d a -> Maybe (Unit 'Metric d a)

-- | Forms the exact version of a <a>Unit</a>.
exactify :: Unit m d a -> Unit m d ExactPi

-- | Shows the value of a <a>Quantity</a> expressed in a specified
--   <a>Unit</a> of the same <a>Dimension</a>.
--   
--   Uses non-breaking spaces between the value and the unit, and within
--   the unit name.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ showIn watt $ (37 *~ volt) * (4 *~ ampere)
--   148.0 W
--   </pre>
showIn :: (Show a, Fractional a) => Unit m d a -> Quantity d a -> String

-- | A KnownVariant is one whose term-level <a>Dimensional</a> values we
--   can represent with an associated data family instance and manipulate
--   with certain functions, not all of which are exported from the
--   package.
--   
--   Each validly constructed type of kind <a>Variant</a> has a
--   <a>KnownVariant</a> instance.
class KnownVariant (v :: Variant)

-- | Maps over the underlying representation of a dimensional value. The
--   caller is responsible for ensuring that the supplied function respects
--   the dimensional abstraction. This means that the function must
--   preserve numerical values, or linearly scale them while preserving the
--   origin.
dmap :: KnownVariant v => (a1 -> a2) -> Dimensional v d a1 -> Dimensional v d a2

-- | Convenient conversion between numerical types while retaining
--   dimensional information.
--   
--   <pre>
--   &gt;&gt;&gt; let x = (37 :: Rational) *~ poundMass
--   
--   &gt;&gt;&gt; changeRep x :: Mass Double
--   16.78291769 kg
--   </pre>
changeRep :: (KnownVariant v, Real a, Fractional b) => Dimensional v d a -> Dimensional v d b

-- | Convenient conversion from exactly represented values while retaining
--   dimensional information.
changeRepApproximate :: (KnownVariant v, Floating b) => Dimensional v d ExactPi -> Dimensional v d b

-- | Converts a <a>Unit</a> into a lens from <a>Quantity</a>s to values.
asLens :: Fractional a => Unit m d a -> forall f. Functor f => (a -> f a) -> Quantity d a -> f (Quantity d a)


-- | <h1>Summary</h1>
--   
--   This module defines type synonyms for common dimensionalities and the
--   associated quantity types. Additional dimensionalities and quantity
--   types will be added on an as-needed basis.
--   
--   The definitions in this module are grouped so that a type synonym for
--   the dimensionality is defined first in terms of base dimension
--   exponents. Then a type synonym for the corresponding quantity type is
--   defined. If there are several quantity types with the same
--   dimensionality type synonyms are provided for each quantity type.
--   
--   <h1>References</h1>
--   
--   <ol>
--   <li><a>http://physics.nist.gov/Pubs/SP811/</a></li>
--   </ol>
module Numeric.Units.Dimensional.Quantities
type Area = Quantity DArea
type Volume = Quantity DVolume
type Velocity = Quantity DVelocity
type Acceleration = Quantity DAcceleration
type WaveNumber = Quantity DWaveNumber
type MassDensity = Quantity DMassDensity
type Density = MassDensity
type SpecificVolume = Quantity DSpecificVolume
type CurrentDensity = Quantity DCurrentDensity
type MagneticFieldStrength = Quantity DMagneticFieldStrength
type AmountOfSubstanceConcentration = Quantity DAmountOfSubstanceConcentration
type Concentration = AmountOfSubstanceConcentration
type Luminance = Quantity DLuminance
type PlaneAngle = Dimensionless
type SolidAngle = Dimensionless
type Frequency = Quantity DFrequency
type Force = Quantity DForce
type Pressure = Quantity DPressure
type Stress = Quantity DStress
type Energy = Quantity DEnergy
type Work = Quantity DWork
type QuantityOfHeat = Quantity DQuantityOfHeat
type Power = Quantity DPower
type RadiantFlux = Quantity DRadiantFlux
type ElectricCharge = Quantity DElectricCharge
type QuantityOfElectricity = Quantity DQuantityOfElectricity
type ElectricPotential = Quantity DElectricPotential
type PotentialDifference = Quantity DPotentialDifference
type ElectromotiveForce = Quantity DElectromotiveForce
type Capacitance = Quantity DCapacitance
type ElectricResistance = Quantity DElectricResistance
type ElectricConductance = Quantity DElectricConductance
type MagneticFlux = Quantity DMagneticFlux
type MagneticFluxDensity = Quantity DMagneticFluxDensity
type Inductance = Quantity DInductance
type LuminousFlux = Quantity DLuminousFlux
type Illuminance = Quantity DIlluminance
type CelsiusTemperature = Quantity DCelsiusTemperature
type Activity = Quantity DActivity
type AbsorbedDose = Quantity DAbsorbedDose
type SpecificEnergy = Quantity DSpecificEnergy
type Kerma = Quantity DKerma
type DoseEquivalent = Quantity DDoseEquivalent
type AmbientDoseEquivalent = DoseEquivalent
type DirectionalDoseEquivalent = DoseEquivalent
type PersonalDoseEquivalent = DoseEquivalent
type EquivalentDose = DoseEquivalent
type CatalyticActivity = Quantity DCatalyticActivity
type AngularVelocity = Quantity DAngularVelocity
type AngularAcceleration = Quantity DAngularAcceleration
type DynamicViscosity = Quantity DDynamicViscosity
type MomentOfForce = Quantity DMomentOfForce
type SurfaceTension = Quantity DSurfaceTension
type HeatFluxDensity = Quantity DHeatFluxDensity
type Irradiance = Quantity DIrradiance
type RadiantIntensity = Quantity DRadiantIntensity
type Radiance = Quantity DRadiance
type HeatCapacity = Quantity DHeatCapacity
type Entropy = Quantity DEntropy
type SpecificHeatCapacity = Quantity DSpecificHeatCapacity
type SpecificEntropy = Quantity DSpecificEntropy
type ThermalConductivity = Quantity DThermalConductivity
type EnergyDensity = Quantity DEnergyDensity
type ElectricFieldStrength = Quantity DElectricFieldStrength
type ElectricChargeDensity = Quantity DElectricChargeDensity
type ElectricFluxDensity = Quantity DElectricFluxDensity
type Permittivity = Quantity DPermittivity
type Permeability = Quantity DPermeability
type MolarEnergy = Quantity DMolarEnergy
type MolarEntropy = Quantity DMolarEntropy
type MolarHeatCapacity = Quantity DMolarHeatCapacity
type Exposure = Quantity DExposure
type AbsorbedDoseRate = Quantity DAbsorbedDoseRate
type Impulse = Quantity DImpulse
type Momentum = Quantity DMomentum
type MassFlow = Quantity DMassFlow
type VolumeFlow = Quantity DVolumeFlow
type GravitationalParameter = Quantity DGravitationalParameter
type KinematicViscosity = Quantity DKinematicViscosity
type FirstMassMoment = Quantity DFirstMassMoment
type MomentOfInertia = Quantity DMomentOfInertia
type AngularMomentum = Quantity DAngularMomentum
type ThermalResistivity = Quantity DThermalResistivity
type ThermalConductance = Quantity DThermalConductance
type ThermalResistance = Quantity DThermalResistance
type HeatTransferCoefficient = Quantity DHeatTransferCoefficient
type ThermalAdmittance = HeatTransferCoefficient
type ThermalInsulance = Quantity DThermalInsulance
type Jerk = Quantity DJerk
type Angle = PlaneAngle
type Thrust = Force
type Torque = MomentOfForce
type EnergyPerUnitMass = SpecificEnergy

-- | Constructs a unit of area from a unit of length, taking the area of a
--   square whose sides are that length.
--   
--   <pre>
--   &gt;&gt;&gt; 64 *~ square meter == (8 *~ meter) ^ pos2
--   True
--   </pre>
square :: (Fractional a, Typeable m) => Unit m DLength a -> Unit 'NonMetric DArea a

-- | Constructs a unit of volume from a unit of length, taking the volume
--   of a cube whose sides are that length.
--   
--   <pre>
--   &gt;&gt;&gt; 64 *~ cubic meter == (4 *~ meter) ^ pos3
--   True
--   </pre>
cubic :: (Fractional a, Typeable m) => Unit m DLength a -> Unit 'NonMetric DVolume a
type DArea = 'Dim 'Pos2 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DVolume = 'Dim 'Pos3 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DVelocity = 'Dim 'Pos1 'Zero 'Neg1 'Zero 'Zero 'Zero 'Zero
type DAcceleration = 'Dim 'Pos1 'Zero 'Neg2 'Zero 'Zero 'Zero 'Zero
type DWaveNumber = 'Dim 'Neg1 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DMassDensity = 'Dim 'Neg3 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DDensity = DMassDensity
type DSpecificVolume = 'Dim 'Pos3 'Neg1 'Zero 'Zero 'Zero 'Zero 'Zero
type DCurrentDensity = 'Dim 'Neg2 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero
type DMagneticFieldStrength = 'Dim 'Neg1 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero
type DAmountOfSubstanceConcentration = 'Dim 'Neg3 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero
type DConcentration = DAmountOfSubstanceConcentration
type DLuminance = 'Dim 'Neg2 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1
type DPlaneAngle = DOne
type DSolidAngle = DOne
type DFrequency = 'Dim 'Zero 'Zero 'Neg1 'Zero 'Zero 'Zero 'Zero
type DForce = 'Dim 'Pos1 'Pos1 'Neg2 'Zero 'Zero 'Zero 'Zero
type DPressure = 'Dim 'Neg1 'Pos1 'Neg2 'Zero 'Zero 'Zero 'Zero
type DStress = DPressure
type DEnergy = 'Dim 'Pos2 'Pos1 'Neg2 'Zero 'Zero 'Zero 'Zero
type DWork = DEnergy
type DQuantityOfHeat = DEnergy
type DPower = 'Dim 'Pos2 'Pos1 'Neg3 'Zero 'Zero 'Zero 'Zero
type DRadiantFlux = DPower
type DElectricCharge = 'Dim 'Zero 'Zero 'Pos1 'Pos1 'Zero 'Zero 'Zero
type DQuantityOfElectricity = DElectricCharge
type DElectricPotential = 'Dim 'Pos2 'Pos1 'Neg3 'Neg1 'Zero 'Zero 'Zero
type DPotentialDifference = DElectricPotential
type DElectromotiveForce = DElectricPotential
type DCapacitance = 'Dim 'Neg2 'Neg1 'Pos4 'Pos2 'Zero 'Zero 'Zero
type DElectricResistance = 'Dim 'Pos2 'Pos1 'Neg3 'Neg2 'Zero 'Zero 'Zero
type DElectricConductance = 'Dim 'Neg2 'Neg1 'Pos3 'Pos2 'Zero 'Zero 'Zero
type DMagneticFlux = 'Dim 'Pos2 'Pos1 'Neg2 'Neg1 'Zero 'Zero 'Zero
type DMagneticFluxDensity = 'Dim 'Zero 'Pos1 'Neg2 'Neg1 'Zero 'Zero 'Zero
type DInductance = 'Dim 'Pos2 'Pos1 'Neg2 'Neg2 'Zero 'Zero 'Zero
type DLuminousFlux = DLuminousIntensity
type DIlluminance = 'Dim 'Neg2 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1
type DCelsiusTemperature = DThermodynamicTemperature
type DActivity = DFrequency
type DAbsorbedDose = 'Dim 'Pos2 'Zero 'Neg2 'Zero 'Zero 'Zero 'Zero
type DSpecificEnergy = DAbsorbedDose
type DKerma = DAbsorbedDose
type DDoseEquivalent = DAbsorbedDose
type DAmbientDoseEquivalent = DDoseEquivalent
type DDirectionalDoseEquivalent = DDoseEquivalent
type DPersonalDoseEquivalent = DDoseEquivalent
type DEquivalentDose = DDoseEquivalent
type DCatalyticActivity = 'Dim 'Zero 'Zero 'Neg1 'Zero 'Zero 'Pos1 'Zero
type DAngularVelocity = DFrequency
type DAngularAcceleration = 'Dim 'Zero 'Zero 'Neg2 'Zero 'Zero 'Zero 'Zero
type DDynamicViscosity = 'Dim 'Neg1 'Pos1 'Neg1 'Zero 'Zero 'Zero 'Zero
type DMomentOfForce = DEnergy
type DSurfaceTension = 'Dim 'Zero 'Pos1 'Neg2 'Zero 'Zero 'Zero 'Zero
type DHeatFluxDensity = 'Dim 'Zero 'Pos1 'Neg3 'Zero 'Zero 'Zero 'Zero
type DIrradiance = DHeatFluxDensity
type DRadiantIntensity = DPower
type DRadiance = DIrradiance
type DHeatCapacity = 'Dim 'Pos2 'Pos1 'Neg2 'Zero 'Neg1 'Zero 'Zero
type DEntropy = DHeatCapacity
type DSpecificHeatCapacity = 'Dim 'Pos2 'Zero 'Neg2 'Zero 'Neg1 'Zero 'Zero
type DSpecificEntropy = DSpecificHeatCapacity
type DThermalConductivity = 'Dim 'Pos1 'Pos1 'Neg3 'Zero 'Neg1 'Zero 'Zero
type DEnergyDensity = DPressure
type DElectricFieldStrength = 'Dim 'Pos1 'Pos1 'Neg3 'Neg1 'Zero 'Zero 'Zero
type DElectricChargeDensity = 'Dim 'Neg3 'Zero 'Pos1 'Pos1 'Zero 'Zero 'Zero
type DElectricFluxDensity = 'Dim 'Neg2 'Zero 'Pos1 'Pos1 'Zero 'Zero 'Zero
type DPermittivity = 'Dim 'Neg3 'Neg1 'Pos4 'Pos2 'Zero 'Zero 'Zero
type DPermeability = 'Dim 'Pos1 'Pos1 'Neg2 'Neg2 'Zero 'Zero 'Zero
type DMolarEnergy = 'Dim 'Pos2 'Pos1 'Neg2 'Zero 'Zero 'Neg1 'Zero
type DMolarEntropy = 'Dim 'Pos2 'Pos1 'Neg2 'Zero 'Neg1 'Neg1 'Zero
type DMolarHeatCapacity = DMolarEntropy
type DExposure = 'Dim 'Zero 'Neg1 'Pos1 'Pos1 'Zero 'Zero 'Zero
type DAbsorbedDoseRate = 'Dim 'Pos2 'Zero 'Neg3 'Zero 'Zero 'Zero 'Zero
type DImpulse = 'Dim 'Pos1 'Pos1 'Neg1 'Zero 'Zero 'Zero 'Zero
type DMomentum = DImpulse
type DMassFlow = 'Dim 'Zero 'Pos1 'Neg1 'Zero 'Zero 'Zero 'Zero
type DVolumeFlow = 'Dim 'Pos3 'Zero 'Neg1 'Zero 'Zero 'Zero 'Zero
type DGravitationalParameter = 'Dim 'Pos3 'Zero 'Neg2 'Zero 'Zero 'Zero 'Zero
type DKinematicViscosity = 'Dim 'Pos2 'Zero 'Neg1 'Zero 'Zero 'Zero 'Zero
type DFirstMassMoment = 'Dim 'Pos1 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DMomentOfInertia = 'Dim 'Pos2 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DAngularMomentum = 'Dim 'Pos2 'Pos1 'Neg1 'Zero 'Zero 'Zero 'Zero
type DThermalResistivity = 'Dim 'Neg1 'Neg1 'Pos3 'Zero 'Pos1 'Zero 'Zero
type DThermalConductance = 'Dim 'Pos2 'Pos1 'Neg3 'Zero 'Neg1 'Zero 'Zero
type DThermalResistance = 'Dim 'Neg2 'Neg1 'Pos3 'Zero 'Pos1 'Zero 'Zero
type DHeatTransferCoefficient = 'Dim 'Zero 'Pos1 'Neg3 'Zero 'Neg1 'Zero 'Zero
type DThermalAdmittance = DHeatTransferCoefficient
type DThermalInsulance = 'Dim 'Zero 'Neg1 'Pos3 'Zero 'Pos1 'Zero 'Zero
type DJerk = 'Dim 'Pos1 'Zero 'Neg3 'Zero 'Zero 'Zero 'Zero
type DAngle = DPlaneAngle
type DThrust = DForce
type DTorque = DMomentOfForce
type DEnergyPerUnitMass = DSpecificEnergy


-- | <h1>Summary</h1>
--   
--   This module defines the SI prefixes, the SI base units and the SI
--   derived units. It also defines the units outside of the SI that are
--   accepted for use with the SI. Any chapters, sections or tables
--   referenced are from <a>[1]</a> unless otherwise specified.
--   
--   <h1>References</h1>
--   
--   <ol>
--   <li><a>http://physics.nist.gov/Pubs/SP811/</a></li>
--   <li><a>http://en.wikipedia.org/wiki/Minute_of_arc</a></li>
--   <li><a>http://en.wikipedia.org/wiki/Astronomical_unit</a></li>
--   </ol>
module Numeric.Units.Dimensional.SIUnits
metre :: Num a => Unit 'Metric DLength a
meter :: Num a => Unit 'Metric DLength a
gram :: Fractional a => Unit 'Metric DMass a
second :: Num a => Unit 'Metric DTime a
ampere :: Num a => Unit 'Metric DElectricCurrent a
kelvin :: Num a => Unit 'Metric DThermodynamicTemperature a
mole :: Num a => Unit 'Metric DAmountOfSubstance a
candela :: Num a => Unit 'Metric DLuminousIntensity a
radian :: Num a => Unit 'Metric DPlaneAngle a
steradian :: Num a => Unit 'Metric DSolidAngle a
hertz :: Num a => Unit 'Metric DFrequency a
newton :: Num a => Unit 'Metric DForce a
pascal :: Num a => Unit 'Metric DPressure a
joule :: Num a => Unit 'Metric DEnergy a
watt :: Num a => Unit 'Metric DPower a
coulomb :: Num a => Unit 'Metric DElectricCharge a
volt :: Num a => Unit 'Metric DElectricPotential a
farad :: Num a => Unit 'Metric DCapacitance a
ohm :: Num a => Unit 'Metric DElectricResistance a
siemens :: Num a => Unit 'Metric DElectricConductance a
weber :: Num a => Unit 'Metric DMagneticFlux a
tesla :: Num a => Unit 'Metric DMagneticFluxDensity a
henry :: Num a => Unit 'Metric DInductance a
lumen :: Num a => Unit 'Metric DLuminousFlux a
lux :: Num a => Unit 'Metric DIlluminance a
degreeCelsius :: Num a => Unit 'Metric DCelsiusTemperature a
fromDegreeCelsiusAbsolute :: Floating a => a -> ThermodynamicTemperature a
toDegreeCelsiusAbsolute :: Floating a => ThermodynamicTemperature a -> a
becquerel :: Num a => Unit 'Metric DActivity a
gray :: Num a => Unit 'Metric DAbsorbedDose a
sievert :: Num a => Unit 'Metric DDoseEquivalent a
katal :: Num a => Unit 'Metric DCatalyticActivity a
minute :: Num a => Unit 'NonMetric DTime a
hour :: Num a => Unit 'NonMetric DTime a
day :: Num a => Unit 'NonMetric DTime a
hectare :: Fractional a => Unit 'NonMetric DArea a
litre :: Fractional a => Unit 'Metric DVolume a
liter :: Fractional a => Unit 'Metric DVolume a
tonne :: Num a => Unit 'Metric DMass a
metricTon :: Num a => Unit 'Metric DMass a
degree :: Floating a => Unit 'NonMetric DPlaneAngle a
arcminute :: Floating a => Unit 'NonMetric DPlaneAngle a
arcsecond :: Floating a => Unit 'NonMetric DPlaneAngle a
degreeOfArc :: Floating a => Unit 'NonMetric DPlaneAngle a
minuteOfArc :: Floating a => Unit 'NonMetric DPlaneAngle a
secondOfArc :: Floating a => Unit 'NonMetric DPlaneAngle a
astronomicalUnit :: Num a => Unit 'NonMetric DLength a
deka :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
deca :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
hecto :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
kilo :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
mega :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
giga :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
tera :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
peta :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
exa :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
zetta :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
yotta :: Num a => Unit 'Metric d a -> Unit 'NonMetric d a
deci :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
centi :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
milli :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
micro :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
nano :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
pico :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
femto :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
atto :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
zepto :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
yocto :: Fractional a => Unit 'Metric d a -> Unit 'NonMetric d a
data Prefix
applyPrefix :: Fractional a => Prefix -> Unit 'Metric d a -> Unit 'NonMetric d a

-- | A list of all <a>Prefix</a>es defined by the SI.
siPrefixes :: [Prefix]


-- | <h1>Summary</h1>
--   
--   This module supplies a convenient set of imports for working with the
--   dimensional package, including aliases for common <a>Quantity</a>s and
--   <a>Dimension</a>s, and a comprehensive set of SI units and units
--   accepted for use with the SI.
--   
--   It re-exports the <a>Prelude</a>, hiding arithmetic functions whose
--   names collide with the dimensionally-typed versions supplied by this
--   package.
module Numeric.Units.Dimensional.Prelude

-- | Dimensional values inhabit this class, which allows access to a
--   term-level representation of their dimension.
class HasDynamicDimension a => HasDimension a

-- | Obtains a term-level representation of a value's dimension.
dimension :: HasDimension a => a -> Dimension'

-- | A physical dimension, encoded as 7 integers, representing a
--   factorization of the dimension into the 7 SI base dimensions. By
--   convention they are stored in the same order as in the
--   <a>Dimension</a> data kind.
data Dimension'
Dim' :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> Dimension'

-- | A KnownDimension is one for which we can construct a term-level
--   representation. Each validly constructed type of kind <a>Dimension</a>
--   has a <a>KnownDimension</a> instance.
--   
--   While <a>KnownDimension</a> is a constraint synonym, the presence of
--   <tt><a>KnownDimension</a> d</tt> in a context allows use of
--   <tt><a>dimension</a> :: <a>Proxy</a> d -&gt; <a>Dimension'</a></tt>.
type KnownDimension (d :: Dimension) = HasDimension (Proxy d)

-- | Cube root is a special case of <a>NRoot</a> with order 3.
type Cbrt d = NRoot d 'Pos3

-- | Square root is a special case of <a>NRoot</a> with order 2.
type Sqrt d = NRoot d 'Pos2

-- | Roots of dimensions corresponds to division of the base dimensions'
--   exponents by the order of the root.
type family NRoot (d :: Dimension) (x :: TypeInt)

-- | Powers of dimensions corresponds to multiplication of the base
--   dimensions' exponents by the exponent.
--   
--   We limit ourselves to integer powers of Dimensionals as fractional
--   powers make little physical sense.
type family (d :: Dimension) ^ (x :: TypeInt)
infixr 8 ^

-- | The reciprocal of a dimension is defined as the result of dividing
--   <a>DOne</a> by it, or of negating each of the base dimensions'
--   exponents.
type Recip (d :: Dimension) = DOne / d

-- | Division of dimensions corresponds to subtraction of the base
--   dimensions' exponents.
type family (a :: Dimension) / (d :: Dimension)
infixl 7 /

-- | Multiplication of dimensions corresponds to adding of the base
--   dimensions' exponents.
type family (a :: Dimension) * (b :: Dimension)
infixl 7 *
type DLuminousIntensity = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1
type DAmountOfSubstance = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero
type DThermodynamicTemperature = 'Dim 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero
type DElectricCurrent = 'Dim 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero
type DTime = 'Dim 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero
type DMass = 'Dim 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DLength = 'Dim 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero

-- | The type-level dimension of dimensionless values.
type DOne = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero

-- | Represents a physical dimension in the basis of the 7 SI base
--   dimensions, where the respective dimensions are represented by type
--   variables using the following convention:
--   
--   <ul>
--   <li>l: Length</li>
--   <li>m: Mass</li>
--   <li>t: Time</li>
--   <li>i: Electric current</li>
--   <li>th: Thermodynamic temperature</li>
--   <li>n: Amount of substance</li>
--   <li>j: Luminous intensity</li>
--   </ul>
--   
--   For the equivalent term-level representation, see <a>Dimension'</a>
data Dimension
Dim :: TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> Dimension

-- | Encodes whether a unit is a metric unit, that is, whether it can be
--   combined with a metric prefix to form a related unit.
data Metricality

-- | Capable of receiving a metric prefix.
Metric :: Metricality

-- | Incapable of receiving a metric prefix.
NonMetric :: Metricality

-- | A KnownVariant is one whose term-level <a>Dimensional</a> values we
--   can represent with an associated data family instance and manipulate
--   with certain functions, not all of which are exported from the
--   package.
--   
--   Each validly constructed type of kind <a>Variant</a> has a
--   <a>KnownVariant</a> instance.
class KnownVariant (v :: Variant) where {
    
    -- | A dimensional value, either a <a>Quantity</a> or a <a>Unit</a>,
    --   parameterized by its <a>Dimension</a> and representation.
    data family Dimensional v :: Dimension -> Type -> Type;
}

-- | A dimensional quantity.
type Quantity = SQuantity One

-- | A unit of measurement.
type Unit (m :: Metricality) = Dimensional ('DUnit m)

-- | A polymorphic <a>Unit</a> which can be used in place of the coherent
--   SI base unit of any dimension. This allows polymorphic quantity
--   creation and destruction without exposing the <a>Dimensional</a>
--   constructor.
siUnit :: forall d a. (KnownDimension d, Num a) => Unit 'NonMetric d a

-- | Shows the value of a <a>Quantity</a> expressed in a specified
--   <a>Unit</a> of the same <a>Dimension</a>.
--   
--   Uses non-breaking spaces between the value and the unit, and within
--   the unit name.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ showIn watt $ (37 *~ volt) * (4 *~ ampere)
--   148.0 W
--   </pre>
showIn :: (Show a, Fractional a) => Unit m d a -> Quantity d a -> String
type LuminousIntensity = Quantity DLuminousIntensity
type AmountOfSubstance = Quantity DAmountOfSubstance
type ThermodynamicTemperature = Quantity DThermodynamicTemperature
type ElectricCurrent = Quantity DElectricCurrent
type Time = Quantity DTime
type Mass = Quantity DMass
type Length = Quantity DLength
type Dimensionless = Quantity DOne

-- | Extracts the <a>UnitName</a> of a <a>Unit</a>.
name :: Unit m d a -> UnitName m

-- | Extracts the exact value of a <a>Unit</a>, expressed in terms of the
--   SI coherent derived unit (see <a>siUnit</a>) of the same
--   <a>Dimension</a>.
--   
--   Note that the actual value may in some cases be approximate, for
--   example if the unit is defined by experiment.
exactValue :: Unit m d a -> ExactPi

-- | Discards potentially unwanted type level information about a
--   <a>Unit</a>.
weaken :: Unit m d a -> Unit 'NonMetric d a

-- | Attempts to convert a <a>Unit</a> which may or may not be
--   <a>Metric</a> to one which is certainly <a>Metric</a>.
strengthen :: Unit m d a -> Maybe (Unit 'Metric d a)

-- | Forms the exact version of a <a>Unit</a>.
exactify :: Unit m d a -> Unit m d ExactPi

-- | Forms a <a>Quantity</a> by multipliying a number and a unit.
(*~) :: Num a => a -> Unit m d a -> Quantity d a
infixl 7 *~

-- | Divides a <a>Quantity</a> by a <a>Unit</a> of the same physical
--   dimension, obtaining the numerical value of the quantity expressed in
--   that unit.
(/~) :: Fractional a => Quantity d a -> Unit m d a -> a
infixl 7 /~

-- | Multiplies two <a>Quantity</a>s or two <a>Unit</a>s.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <a>NonMetric</a>.
(*) :: (KnownVariant v1, KnownVariant v2, KnownVariant (v1 * v2), Num a) => Dimensional v1 d1 a -> Dimensional v2 d2 a -> Dimensional (v1 * v2) (d1 * d2) a
infixl 7 *

-- | Divides one <a>Quantity</a> by another or one <a>Unit</a> by another.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <tt>NotPrefixable</tt>.
(/) :: (KnownVariant v1, KnownVariant v2, KnownVariant (v1 / v2), Fractional a) => Dimensional v1 d1 a -> Dimensional v2 d2 a -> Dimensional (v1 / v2) (d1 / d2) a
infixl 7 /

-- | Forms the reciprocal of a <a>Quantity</a>, which has the reciprocal
--   dimension.
--   
--   <pre>
--   &gt;&gt;&gt; recip $ 47 *~ hertz
--   2.127659574468085e-2 s
--   </pre>
recip :: Fractional a => Quantity d a -> Quantity (Recip d) a

-- | Raises a <a>Quantity</a> or <a>Unit</a> to an integer power.
--   
--   Because the power chosen impacts the <a>Dimension</a> of the result,
--   it is necessary to supply a type-level representation of the exponent
--   in the form of a <a>Proxy</a> to some <tt>TypeInt</tt>. Convenience
--   values <tt>pos1</tt>, <a>pos2</a>, <tt>neg1</tt>, ... are supplied by
--   the <a>Numeric.NumType.DK.Integers</a> module. The most commonly used
--   ones are also reexported by <a>Numeric.Units.Dimensional.Prelude</a>.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <tt>NotPrefixable</tt>.
(^) :: (Fractional a, KnownTypeInt i, KnownVariant v, KnownVariant (Weaken v)) => Dimensional v d1 a -> Proxy i -> Dimensional (Weaken v) (d1 ^ i) a
infixr 8 ^

-- | Negates the value of a <a>Quantity</a>.
negate :: Num a => Quantity d a -> Quantity d a

-- | Adds two <a>Quantity</a>s.
(+) :: Num a => Quantity d a -> Quantity d a -> Quantity d a
infixl 6 +

-- | Subtracts one <a>Quantity</a> from another.
(-) :: Num a => Quantity d a -> Quantity d a -> Quantity d a
infixl 6 -

-- | Takes the absolute value of a <a>Quantity</a>.
abs :: Num a => Quantity d a -> Quantity d a

-- | Takes the sign of a <a>Quantity</a>. The functions <a>abs</a> and
--   <a>signum</a> satisy the law that:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   The sign is either <tt>negate _1</tt> (negative), <tt>_0</tt> (zero),
--   or <tt>_1</tt> (positive).
signum :: Num a => Quantity d a -> Dimensionless a

-- | Computes the nth root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application of this operator
--   where the result would have a fractional dimension or where n is zero.
--   
--   Because the root chosen impacts the <a>Dimension</a> of the result, it
--   is necessary to supply a type-level representation of the root in the
--   form of a <a>Proxy</a> to some <tt>TypeInt</tt>. Convenience values
--   <tt>pos1</tt>, <a>pos2</a>, <tt>neg1</tt>, ... are supplied by the
--   <a>Numeric.NumType.DK.Integers</a> module. The most commonly used ones
--   are also reexported by <a>Numeric.Units.Dimensional.Prelude</a>.
--   
--   n must not be zero. Negative roots are defined such that <tt>nroot
--   (Proxy :: Proxy (Negate n)) x == nroot (Proxy :: Proxy n) (recip
--   x)</tt>.
--   
--   Also available in operator form, see <a>^/</a>.
nroot :: (KnownTypeInt n, Floating a) => Proxy n -> Quantity d a -> Quantity (NRoot d n) a

-- | Computes the square root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application where the
--   supplied quantity does not have a square dimension.
--   
--   <pre>
--   (x :: Area Double) &gt;= _0 ==&gt; sqrt x == nroot pos2 x
--   </pre>
sqrt :: Floating a => Quantity d a -> Quantity (Sqrt d) a

-- | Computes the cube root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application where the
--   supplied quantity does not have a cubic dimension.
--   
--   <pre>
--   (x :: Volume Double) &gt;= _0 ==&gt; cbrt x == nroot pos3 x
--   </pre>
cbrt :: Floating a => Quantity d a -> Quantity (Cbrt d) a

-- | Computes the nth root of a <a>Quantity</a> using <a>**</a>.
--   
--   The <a>NRoot</a> type family will prevent application of this operator
--   where the result would have a fractional dimension or where n is zero.
--   
--   Because the root chosen impacts the <a>Dimension</a> of the result, it
--   is necessary to supply a type-level representation of the root in the
--   form of a <a>Proxy</a> to some <tt>TypeInt</tt>. Convenience values
--   <tt>pos1</tt>, <a>pos2</a>, <tt>neg1</tt>, ... are supplied by the
--   <a>Numeric.NumType.DK.Integers</a> module. The most commonly used ones
--   are also reexported by <a>Numeric.Units.Dimensional.Prelude</a>.
--   
--   Also available in prefix form, see <a>nroot</a>.
(^/) :: (KnownTypeInt n, Floating a) => Quantity d a -> Proxy n -> Quantity (NRoot d n) a
infixr 8 ^/

-- | Applies <a>*~</a> to all values in a functor.
(*~~) :: (Functor f, Num a) => f a -> Unit m d a -> f (Quantity d a)
infixl 7 *~~

-- | Applies <a>/~</a> to all values in a functor.
(/~~) :: forall f m d a. (Functor f, Fractional a) => f (Quantity d a) -> Unit m d a -> f a
infixl 7 /~~

-- | The sum of all elements in a foldable structure.
--   
--   <pre>
--   &gt;&gt;&gt; sum ([] :: [Mass Double])
--   0.0 kg
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [12.4 *~ meter, 1 *~ foot]
--   12.7048 m
--   </pre>
sum :: (Num a, Foldable f) => f (Quantity d a) -> Quantity d a

-- | The product of all elements in a foldable structure.
--   
--   <pre>
--   &gt;&gt;&gt; product ([] :: [Dimensionless Double])
--   1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [pi, _4, 0.36 *~ one]
--   4.523893421169302
--   </pre>
product :: (Num a, Foldable f) => f (Dimensionless a) -> Dimensionless a

-- | The arithmetic mean of all elements in a foldable structure.
--   
--   <pre>
--   &gt;&gt;&gt; mean [pi, _7]
--   5.070796326794897
--   </pre>
mean :: (Fractional a, Foldable f) => f (Quantity d a) -> Quantity d a

-- | The length of the foldable data structure as a <a>Dimensionless</a>.
--   This can be useful for purposes of e.g. calculating averages.
--   
--   <pre>
--   &gt;&gt;&gt; dimensionlessLength ["foo", "bar"]
--   2
--   </pre>
dimensionlessLength :: (Num a, Foldable f) => f b -> Dimensionless a

-- | Returns a list of quantities between given bounds.
--   
--   <pre>
--   n &lt;= 0 ==&gt; nFromTo (x :: Mass Double) (y :: Mass Double) n == [x, y]
--   </pre>
--   
--   <pre>
--   (x :: Length Double) &lt;= (y :: Length Double) ==&gt; all (\z -&gt; x &lt;= z &amp;&amp; z &lt;= y) (nFromTo x y n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nFromTo _0 _3 2
--   [0.0,1.0,2.0,3.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nFromTo _1 _0 7
--   [1.0,0.875,0.75,0.625,0.5,0.375,0.25,0.125,0.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nFromTo _0 _1 (-5)
--   [0.0,1.0]
--   </pre>
nFromTo :: (Fractional a, Integral b) => Quantity d a -> Quantity d a -> b -> [Quantity d a]
exp :: Floating a => Dimensionless a -> Dimensionless a
log :: Floating a => Dimensionless a -> Dimensionless a
sin :: Floating a => Dimensionless a -> Dimensionless a
cos :: Floating a => Dimensionless a -> Dimensionless a
tan :: Floating a => Dimensionless a -> Dimensionless a
asin :: Floating a => Dimensionless a -> Dimensionless a
acos :: Floating a => Dimensionless a -> Dimensionless a
atan :: Floating a => Dimensionless a -> Dimensionless a
sinh :: Floating a => Dimensionless a -> Dimensionless a
cosh :: Floating a => Dimensionless a -> Dimensionless a
tanh :: Floating a => Dimensionless a -> Dimensionless a
asinh :: Floating a => Dimensionless a -> Dimensionless a
acosh :: Floating a => Dimensionless a -> Dimensionless a
atanh :: Floating a => Dimensionless a -> Dimensionless a
log1p :: Floating a => Dimensionless a -> Dimensionless a
expm1 :: Floating a => Dimensionless a -> Dimensionless a
log1pexp :: Floating a => Dimensionless a -> Dimensionless a
log1mexp :: Floating a => Dimensionless a -> Dimensionless a

-- | Raises a dimensionless quantity to a dimensionless power.
(**) :: Floating a => Dimensionless a -> Dimensionless a -> Dimensionless a
infixr 8 **

-- | Takes the logarithm of the second argument in the base of the first.
--   
--   <pre>
--   &gt;&gt;&gt; logBase _2 _8
--   3.0
--   </pre>
logBase :: Floating a => Dimensionless a -> Dimensionless a -> Dimensionless a

-- | The standard two argument arctangent function. Since it interprets its
--   two arguments in comparison with one another, the input may have any
--   dimension.
--   
--   <pre>
--   &gt;&gt;&gt; atan2 _0 _1
--   0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; atan2 _1 _0
--   1.5707963267948966
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; atan2 _0 (negate _1)
--   3.141592653589793
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; atan2 (negate _1) _0
--   -1.5707963267948966
--   </pre>
atan2 :: RealFloat a => Quantity d a -> Quantity d a -> Dimensionless a

-- | The unit <a>one</a> has dimension <a>DOne</a> and is the base unit of
--   dimensionless values.
--   
--   As detailed in 7.10 "Values of quantities expressed simply as numbers:
--   the unit one, symbol 1" of <a>[1]</a> the unit one generally does not
--   appear in expressions. However, for us it is necessary to use
--   <a>one</a> as we would any other unit to perform the "boxing" of
--   dimensionless values.
one :: Num a => Unit 'NonMetric DOne a

-- | The constant for zero is polymorphic, allowing it to express zero
--   <a>Length</a> or <a>Capacitance</a> or <a>Velocity</a> etc, in
--   addition to the <a>Dimensionless</a> value zero.
_0 :: Num a => Quantity d a
_1 :: Num a => Dimensionless a
_2 :: Num a => Dimensionless a
_3 :: Num a => Dimensionless a
_4 :: Num a => Dimensionless a
_5 :: Num a => Dimensionless a
_6 :: Num a => Dimensionless a
_7 :: Num a => Dimensionless a
_8 :: Num a => Dimensionless a
_9 :: Num a => Dimensionless a
pi :: Floating a => Dimensionless a

-- | Twice <a>pi</a>.
--   
--   For background on <a>tau</a> see
--   <a>http://tauday.com/tau-manifesto</a> (but also feel free to review
--   <a>http://www.thepimanifesto.com)</a>.
tau :: Floating a => Dimensionless a

-- | Convenient conversion between numerical types while retaining
--   dimensional information.
--   
--   <pre>
--   &gt;&gt;&gt; let x = (37 :: Rational) *~ poundMass
--   
--   &gt;&gt;&gt; changeRep x :: Mass Double
--   16.78291769 kg
--   </pre>
changeRep :: (KnownVariant v, Real a, Fractional b) => Dimensional v d a -> Dimensional v d b

-- | Convenient conversion from exactly represented values while retaining
--   dimensional information.
changeRepApproximate :: (KnownVariant v, Floating b) => Dimensional v d ExactPi -> Dimensional v d b

-- | Converts a <a>Unit</a> into a lens from <a>Quantity</a>s to values.
asLens :: Fractional a => Unit m d a -> forall f. Functor f => (a -> f a) -> Quantity d a -> f (Quantity d a)

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is
--   irrational or <a>Approximate</a>. See <a>mkUnitQ</a> for when it is
--   rational and <a>mkUnitZ</a> for when it is an integer.
--   
--   Note that supplying zero as a definining quantity is invalid, as the
--   library relies upon units forming a group under multiplication.
--   
--   Supplying negative defining quantities is allowed and handled
--   gracefully, but is discouraged on the grounds that it may be
--   unexpected by other readers.
mkUnitR :: Floating a => UnitName m -> ExactPi -> Unit m1 d a -> Unit m d a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is
--   rational. See <a>mkUnitZ</a> for when it is an integer and
--   <a>mkUnitR</a> for the general case.
--   
--   For more information see <a>mkUnitR</a>.
mkUnitQ :: Fractional a => UnitName m -> Rational -> Unit m1 d a -> Unit m d a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is an
--   integer. See <a>mkUnitQ</a> for when it is rational and <a>mkUnitR</a>
--   for the general case.
--   
--   For more information see <a>mkUnitR</a>.
mkUnitZ :: Num a => UnitName m -> Integer -> Unit m1 d a -> Unit m d a
pos5 :: Proxy 'Pos5
pos4 :: Proxy 'Pos4
pos3 :: Proxy 'Pos3
pos2 :: Proxy 'Pos2
pos1 :: Proxy 'Pos1
zero :: Proxy 'Zero
neg1 :: Proxy 'Neg1
neg2 :: Proxy 'Neg2
neg3 :: Proxy 'Neg3
neg4 :: Proxy 'Neg4
neg5 :: Proxy 'Neg5

-- | A class for categories. Instances should satisfy the laws
--   
--   <ul>
--   <li><i>Right identity</i> <tt>f <a>.</a> <a>id</a> = f</tt></li>
--   <li><i>Left identity</i> <tt><a>id</a> <a>.</a> f = f</tt></li>
--   <li><i>Associativity</i> <tt>f <a>.</a> (g <a>.</a> h) = (f <a>.</a>
--   g) <a>.</a> h</tt></li>
--   </ul>
class Category (cat :: k -> k -> Type)

-- | the identity morphism
id :: forall (a :: k). Category cat => cat a a

-- | morphism composition
(.) :: forall (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 9 .

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(min(m,n))</i>. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <tt>O(n)</tt>
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <tt>fail</tt> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <i>O(min(m,n))</i>. <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | <i>O(n)</i>. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | <i>O(n)</i>. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. Return all the elements of a list except the last one.
--   The list must be non-empty.
init :: [a] -> [a]

-- | <i>O(n)</i>. Extract the last element of a list, which must be finite
--   and non-empty.
last :: [a] -> a

-- | <i>O(1)</i>. Extract the elements after the head of a list, which must
--   be non-empty.
tail :: [a] -> [a]

-- | <i>O(1)</i>. Extract the first element of a list, which must be
--   non-empty.
head :: [a] -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool


-- | <h1>Summary</h1>
--   
--   This module defines units that are not part of the SI, with the
--   exception of those defined in the
--   <a>Numeric.Units.Dimensional.SIUnits</a> module (units outside of the
--   SI accepted for use with the SI).
--   
--   Any chapters, sections or tables referenced are from <a>[1]</a> unless
--   otherwise specified.
--   
--   <h2>Neper, bel, shannon and the like</h2>
--   
--   The units of section 5.1.2 are purposefully (but not permanently)
--   omitted. In fact the logarithmic units (see section 8.7) are
--   problematic and it is not clear how to implement them. Perhaps with a
--   conversion function similar to for degrees Celsius.
--   
--   <h1>References</h1>
--   
--   <ol>
--   <li><a>http://physics.nist.gov/Pubs/SP811/</a></li>
--   
--   <li><a>http://www.iau.org/science/publications/proceedings_rules/units/</a></li>
--   <li><a>http://en.m.wikipedia.org/wiki/Pressure</a></li>
--   <li><a>http://en.m.wikipedia.org/wiki/Torr</a></li>
--   </ol>
module Numeric.Units.Dimensional.NonSI
electronVolt :: Floating a => Unit 'Metric DEnergy a
unifiedAtomicMassUnit :: Floating a => Unit 'Metric DMass a
dalton :: Floating a => Unit 'Metric DMass a

-- | One percent is one hundrendth.
--   
--   The dimensionless number 0.01 , represented by the symbol %, is
--   commonly used as a dimensionless unit.
--   
--   See section 7.10.2 of the <a>[1]</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ percent
--   1.0e-2
--   </pre>
percent :: Fractional a => Unit 'NonMetric DOne a

-- | One gee is the standard value of the acceleration due to gravity at
--   the Earth's surface, as standardized by CIPM.
--   
--   Note that local values of acceleration due to gravity will differ from
--   the standard gravity.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ gee
--   9.80665 m s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ gee :: Acceleration Rational
--   196133 % 20000 m s^-2
--   </pre>
gee :: Fractional a => Unit 'Metric DAcceleration a

-- | One avoirdupois pound is a mass, exactly defined in terms of the
--   kilogram by the international yard and pound agreement of 1959.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ poundMass
--   0.45359237 kg
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ poundMass :: Mass Rational
--   45359237 % 100000000 kg
--   </pre>
poundMass :: Fractional a => Unit 'NonMetric DMass a

-- | One avoirdupois ounce is one sixteenth of a <a>poundMass</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ ounce
--   2.8349523125e-2 kg
--   </pre>
--   
--   <pre>
--   16 *~ ounce === 1 *~ poundMass
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ ounce :: Mass Rational
--   45359237 % 1600000000 kg
--   </pre>
ounce :: Fractional a => Unit 'NonMetric DMass a

-- | The pound-force is equal to the gravitational force exerted on a mass
--   of one avoirdupois pound on the surface of Earth.
--   
--   This definition is based on standard gravity (the <a>gee</a>) and the
--   international avoirdupois <a>poundMass</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ poundForce
--   4.4482216152605 m kg s^-2
--   </pre>
--   
--   <pre>
--   1 *~ poundForce === 1 *~ poundMass * (1 *~ gee)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ poundForce :: Force Rational
--   8896443230521 % 2000000000000 m kg s^-2
--   </pre>
poundForce :: Fractional a => Unit 'NonMetric DForce a

-- | One mechanical horsepower is by definition the power necessary to
--   apply a force of 550 <a>poundForce</a> through a distance of one
--   <a>foot</a> per <a>second</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ horsepower
--   745.6998715822702 m^2 kg s^-3
--   </pre>
--   
--   <pre>
--   1 *~ horsepower === 550 *~ poundForce * (1 *~ foot) / (1 *~ second)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ horsepower :: Power Rational
--   37284993579113511 % 50000000000000 m^2 kg s^-3
--   </pre>
horsepower :: Fractional a => Unit 'NonMetric DPower a

-- | One btu is is the <a>QuantityOfHeat</a> required to raise the
--   temperature of 1 avoirdupois <a>poundMass</a> of liquid water by 1
--   <a>degreeFahrenheit</a> at a constant pressure of one
--   <a>atmosphere</a>.
--   
--   Because this value must be determined experimentally and varies with
--   temperature, several standardized values of the btu have arisen. This
--   is the value based on the International Steam Table calorie, defined
--   by the Fifth International Conference on the Properties of Steam.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ btu
--   1055.05585262 m^2 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ btu :: Energy Rational
--   52752792631 % 50000000 m^2 kg s^-2
--   </pre>
btu :: Fractional a => Unit 'NonMetric DEnergy a

-- | One short ton is two thousand <a>poundMass</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ shortTon
--   907.18474 kg
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ shortTon :: Mass Rational
--   45359237 % 50000 kg
--   </pre>
shortTon :: Fractional a => Unit 'NonMetric DMass a

-- | One nautical mile is a unit of length, set by international agreement
--   as being exactly 1 852 meters.
--   
--   Historically, it was defined as the distance spanned by one minute of
--   arc along a meridian of the Earth.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ nauticalMile
--   1852.0 m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ nauticalMile :: Length Rational
--   1852 % 1 m
--   </pre>
nauticalMile :: Num a => Unit 'NonMetric DLength a

-- | One knot is a velocity equal to one <a>nauticalMile</a> per
--   <a>hour</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ knot
--   0.5144444444444445 m s^-1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ knot :: Velocity Rational
--   463 % 900 m s^-1
--   </pre>
knot :: Fractional a => Unit 'NonMetric DVelocity a

-- | One revolution is an angle equal to 2 pi radians; a full circle.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ revolution
--   6.283185307179586
--   </pre>
--   
--   <pre>
--   1 *~ revolution === _2 * pi * (1 *~ radian)
--   </pre>
--   
--   <pre>
--   1 *~ revolution === 360 *~ degree
--   </pre>
revolution :: Floating a => Unit 'NonMetric DOne a
solid :: Floating a => Unit 'NonMetric DOne a

-- | The slug is a unit of mass associated with Imperial units and United
--   States customary units. It is a mass that accelerates by 1 foot per
--   second per second when a force of one pound is exerted on it.
--   
--   This definition is based on standard gravity (the <a>gee</a>), the
--   international <a>foot</a>, and the international avoirdupois
--   <a>poundMass</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ slug
--   14.593902937206364 kg
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ slug :: Mass Rational
--   8896443230521 % 609600000000 kg
--   </pre>
slug :: Fractional a => Unit 'NonMetric DMass a

-- | One psi is a pressure of one <a>poundForce</a> per <a>square</a>
--   <a>inch</a> of area.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ psi
--   6894.757293168362 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ psi :: Pressure Rational
--   8896443230521 % 1290320000 m^-1 kg s^-2
--   </pre>
psi :: Fractional a => Unit 'NonMetric DPressure a
teaspoon :: Fractional a => Unit 'NonMetric DVolume a

-- | One international foot is one third of an international <a>yard</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ foot
--   0.3048 m
--   </pre>
--   
--   <pre>
--   3 *~ foot === 1 *~ yard
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ foot :: Length Rational
--   381 % 1250 m
--   </pre>
foot :: Fractional a => Unit 'NonMetric DLength a

-- | One inch is one twelth of a <a>foot</a>.
--   
--   This inch is based on the international <a>foot</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inch
--   2.54e-2 m
--   </pre>
--   
--   <pre>
--   12 *~ inch === 1 *~ foot
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inch :: Length Rational
--   127 % 5000 m
--   </pre>
inch :: Fractional a => Unit 'NonMetric DLength a

-- | One mil is one thousandth of an <a>inch</a>.
--   
--   This mil is based on the international <a>inch</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ mil
--   2.54e-5 m
--   </pre>
--   
--   <pre>
--   1000 *~ mil === 1 *~ inch
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ mil :: Length Rational
--   127 % 5000000 m
--   </pre>
mil :: Fractional a => Unit 'NonMetric DLength a

-- | One yard, as defined by international agreement in 1959, is precisely
--   0.9144 <a>meter</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ yard
--   0.9144 m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ yard :: Length Rational
--   1143 % 1250 m
--   </pre>
yard :: Fractional a => Unit 'NonMetric DLength a

-- | One mile is 5 280 feet.
--   
--   This mile is based on the international <a>foot</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ mile
--   1609.344 m
--   </pre>
--   
--   <pre>
--   1 *~ mile === 5280 *~ foot
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ mile :: Length Rational
--   201168 % 125 m
--   </pre>
mile :: Fractional a => Unit 'NonMetric DLength a

-- | One acre is 43 560 square feet.
--   
--   This acre is based on the international <a>foot</a>. For the acre
--   based on the US Survey Foot, see <a>usSurveyAcre</a>. While both acres
--   are in use, the difference between them is of little consequence for
--   most applications in which either is used.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ acre
--   4046.8564224 m^2
--   </pre>
--   
--   <pre>
--   1 *~ acre === 43560 *~ foot ^ pos2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ acre :: Area Rational
--   316160658 % 78125 m^2
--   </pre>
acre :: Fractional a => Unit 'NonMetric DArea a

-- | One US survey foot is 1200/3937 <a>meter</a>.
--   
--   For the international foot, see <a>foot</a>. Note that this is not the
--   foot in routine use in the United States.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyFoot
--   0.3048006096012192 m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyFoot :: Length Rational
--   1200 % 3937 m
--   </pre>
usSurveyFoot :: Fractional a => Unit 'NonMetric DLength a

-- | One inch is one twelth of a foot.
--   
--   This inch is based on the <a>usSurveyFoot</a>. For the inch based on
--   the international foot, see <a>inch</a>. Note that this is not the
--   inch in routine use in the United States.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyInch
--   2.54000508001016e-2 m
--   </pre>
--   
--   <pre>
--   12 *~ usSurveyInch === 1 *~ usSurveyFoot
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyInch :: Length Rational
--   100 % 3937 m
--   </pre>
usSurveyInch :: Fractional a => Unit 'NonMetric DLength a

-- | One mil is one thousandth of an inch.
--   
--   This mil is based on the <a>usSurveyInch</a>. For the mil based on the
--   international inch, see <a>mil</a>. Note that this is not the mil in
--   routine use in the United States.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyMil
--   2.54000508001016e-5 m
--   </pre>
--   
--   <pre>
--   1000 *~ usSurveyMil === 1 *~ usSurveyInch
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyMil :: Length Rational
--   1 % 39370 m
--   </pre>
usSurveyMil :: Fractional a => Unit 'NonMetric DLength a

-- | One yard is three feet.
--   
--   This yard is based on the <a>usSurveyFoot</a>. For the international
--   yard, see <a>yard</a>. Note that this is not the yard in routine use
--   in the United States.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyYard
--   0.9144018288036576 m
--   </pre>
--   
--   <pre>
--   1 *~ usSurveyYard === 3 *~ usSurveyFoot
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyYard :: Length Rational
--   3600 % 3937 m
--   </pre>
usSurveyYard :: Fractional a => Unit 'NonMetric DLength a

-- | One US survey mile is 5 280 US survey feet.
--   
--   This mile is based on the <a>usSurveyFoot</a>. For the mile based on
--   the international foot, see <a>mile</a>. Note that this is not the
--   mile in routine use in the United States.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyMile
--   1609.3472186944373 m
--   </pre>
--   
--   <pre>
--   1 *~ usSurveyMile === 5280 *~ usSurveyFoot
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyMile :: Length Rational
--   6336000 % 3937 m
--   </pre>
usSurveyMile :: Fractional a => Unit 'NonMetric DLength a

-- | One acre is 43 560 square feet.
--   
--   This acre is based on the <a>usSurveyFoot</a>. For the acre based on
--   the international foot, see <a>acre</a>. While both acres are in use,
--   the difference between them is of little consequence for most
--   applications in which either is used. This is the only acre defined by
--   the UCUM.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyAcre
--   4046.872609874252 m^2
--   </pre>
--   
--   <pre>
--   1 *~ usSurveyAcre === 43560 *~ usSurveyFoot ^ pos2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usSurveyAcre :: Area Rational
--   62726400000 % 15499969 m^2
--   </pre>
usSurveyAcre :: Fractional a => Unit 'NonMetric DArea a

-- | One mean Julian year is a unit of measurement of time defined as
--   exactly 365.25 days of 86 400 <a>second</a>s each.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ year
--   3.15576e7 s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ year :: Time Rational
--   31557600 % 1 s
--   </pre>
year :: Num a => Unit 'NonMetric DTime a

-- | One mean Julian century is one hundred mean Julian <a>year</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ century
--   3.15576e9 s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ century :: Time Rational
--   3155760000 % 1 s
--   </pre>
century :: Num a => Unit 'NonMetric DTime a

-- | The bar is exactly 100 000 <a>pascal</a>.
--   
--   From Wikipedia:
--   
--   It is about equal to the atmospheric pressure on Earth at sea level.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ bar
--   100000.0 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ bar :: Pressure Rational
--   100000 % 1 m^-1 kg s^-2
--   </pre>
bar :: Num a => Unit 'Metric DPressure a

-- | The "standard atmosphere".
--   
--   From Wikipedia <a>[3]</a>:
--   
--   The standard atmosphere (atm) is an established constant. It is
--   approximately equal to typical air pressure at earth mean sea level.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ atmosphere
--   101325.0 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ atmosphere :: Pressure Rational
--   101325 % 1 m^-1 kg s^-2
--   </pre>
atmosphere :: Num a => Unit 'NonMetric DPressure a

-- | The "technical atmosphere"
--   
--   From Wikipedia:
--   
--   A technical atmosphere (symbol: at) is a non-SI unit of pressure equal
--   to one kilogram-force per square centimeter.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ technicalAtmosphere
--   98066.5 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ technicalAtmosphere :: Pressure Rational
--   196133 % 2 m^-1 kg s^-2
--   </pre>
technicalAtmosphere :: Fractional a => Unit 'NonMetric DPressure a

-- | The conventional value for the pressure exerted by a 1 mm high column
--   of mercury.
--   
--   Per Wikipedia <a>[4]</a>, one mmHg (millimeter of mercury) is defined
--   as:
--   
--   The pressure exerted at the base of a column of fluid exactly 1 mm
--   high, when the density of the fluid is exactly 13.5951 g/cm^3, at a
--   place where the acceleration of gravity is exactly 9.80665 m/s^2.
--   
--   The chosen fluid density approximately corresponds to that of mercury
--   at 0 deg. Under most conditions, 1 mmHg is approximately equal to 1
--   <a>torr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ mmHg
--   133.322 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ mmHg :: Pressure Rational
--   66661 % 500 m^-1 kg s^-2
--   </pre>
mmHg :: Fractional a => Unit 'NonMetric DPressure a

-- | The conventional value for the pressure exerted by a 1 inch high
--   column of mercury.
--   
--   Column inches of mercury are also used to measure pressure, especially
--   in meteorological or aeronautical contexts in the United States.
--   
--   This is the value defined by UCUM. For the value defined by NIST, see
--   <a>inHg_NIST</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inHg
--   3386.3788 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inHg :: Pressure Rational
--   8465947 % 2500 m^-1 kg s^-2
--   </pre>
inHg :: Fractional a => Unit 'NonMetric DPressure a

-- | The conventional value for the pressure exerted by a 1 inch high
--   column of mercury.
--   
--   Column inches of mercury are also used to measure pressure, especially
--   in meteorological or aeronautical contexts in the United States.
--   
--   This is the value defined by UCUM. For the value defined by NIST, see
--   <a>inHg_NIST</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inHg_UCUM
--   3386.3788 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inHg_UCUM :: Pressure Rational
--   8465947 % 2500 m^-1 kg s^-2
--   </pre>
inHg_UCUM :: Fractional a => Unit 'NonMetric DPressure a

-- | The conventional value for the pressure exerted by a 1 inch high
--   column of mercury.
--   
--   Column inches of mercury are also used to measure pressure, especially
--   in meteorological or aeronautical contexts in the United States.
--   
--   This is the value defined by NIST. For the value defined by UCUM, see
--   <a>inHg_UCUM</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inHg_NIST
--   3386.389 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ inHg_NIST :: Pressure Rational
--   3386389 % 1000 m^-1 kg s^-2
--   </pre>
inHg_NIST :: Fractional a => Unit 'NonMetric DPressure a

-- | One torr (symbol: Torr) is defined as 1/760 <a>atmosphere</a>, which
--   is approximately equal to 1 <a>mmHg</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ torr
--   133.32236842105263 m^-1 kg s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ torr :: Pressure Rational
--   20265 % 152 m^-1 kg s^-2
--   </pre>
torr :: Fractional a => Unit 'NonMetric DPressure a

-- | The rad is a deprecated unit of <a>AbsorbedDose</a>, defined as 0.01
--   <a>gray</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ rad
--   1.0e-2 m^2 s^-2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ rad :: AbsorbedDose Rational
--   1 % 100 m^2 s^-2
--   </pre>
rad :: Fractional a => Unit 'Metric DAbsorbedDose a

-- | One Stokes is a unit of <a>KinematicViscosity</a> equal to <tt>1 cm^2
--   / s</tt>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ stokes
--   1.0e-4 m^2 s^-1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ stokes :: KinematicViscosity Rational
--   1 % 10000 m^2 s^-1
--   </pre>
stokes :: Fractional a => Unit 'Metric DKinematicViscosity a

-- | One degree Fahrenheit is a unit of relative temperature equal to 5/9
--   <a>kelvin</a>.
--   
--   Note that although the Fahrenheit scale is an absolute temperature
--   scale, this unit is a unit of difference within that scale and
--   measures relative temperature.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ degreeFahrenheit
--   0.5555555555555556 K
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ degreeFahrenheit :: ThermodynamicTemperature Rational
--   5 % 9 K
--   </pre>
degreeFahrenheit :: Fractional a => Unit 'NonMetric DThermodynamicTemperature a

-- | One degree Rankine is a unit of relative temperature equal to 5/9
--   <a>kelvin</a>.
--   
--   Note that although the Rankine scale is an absolute temperature scale,
--   this unit is a unit of difference within that scale and measures
--   relative temperature.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ degreeRankine
--   0.5555555555555556 K
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ degreeRankine :: ThermodynamicTemperature Rational
--   5 % 9 K
--   </pre>
degreeRankine :: Fractional a => Unit 'NonMetric DThermodynamicTemperature a

-- | One imperial gallon is defined exactly in terms of the <a>liter</a> by
--   the Weights and Measures Act 1985.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialGallon
--   4.54609e-3 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialGallon :: Volume Rational
--   454609 % 100000000 m^3
--   </pre>
imperialGallon :: Fractional a => Unit 'NonMetric DVolume a

-- | One imperial quart is one quarter of an <a>imperialGallon</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialQuart
--   1.1365225e-3 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialQuart :: Volume Rational
--   454609 % 400000000 m^3
--   </pre>
imperialQuart :: Fractional a => Unit 'NonMetric DVolume a

-- | One imperial pint is one half of an <a>imperialQuart</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialPint
--   5.6826125e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialPint :: Volume Rational
--   454609 % 800000000 m^3
--   </pre>
imperialPint :: Fractional a => Unit 'NonMetric DVolume a

-- | One imperial cup is one half of an <a>imperialPint</a>.
--   
--   This unit is not in common use and is does not appear in some sources
--   describing the imperial fluid volume units.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialCup
--   2.84130625e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialCup :: Volume Rational
--   454609 % 1600000000 m^3
--   </pre>
imperialCup :: Fractional a => Unit 'NonMetric DVolume a

-- | One imperial gill is one quarter of an <a>imperialPint</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialGill
--   1.420653125e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialGill :: Volume Rational
--   454609 % 3200000000 m^3
--   </pre>
imperialGill :: Fractional a => Unit 'NonMetric DVolume a

-- | One imperial fluid ounce is one twentieth of an <a>imperialPint</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialFluidOunce
--   2.84130625e-5 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ imperialFluidOunce :: Volume Rational
--   454609 % 16000000000 m^3
--   </pre>
imperialFluidOunce :: Fractional a => Unit 'NonMetric DVolume a

-- | One US liquid gallon is a volume of 231 cubic inches.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usGallon
--   3.785411784e-3 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usGallon :: Volume Rational
--   473176473 % 125000000000 m^3
--   </pre>
usGallon :: Fractional a => Unit 'NonMetric DVolume a

-- | One US liquid quart is one quarter of a <a>usGallon</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usQuart
--   9.46352946e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usQuart :: Volume Rational
--   473176473 % 500000000000 m^3
--   </pre>
usQuart :: Fractional a => Unit 'NonMetric DVolume a

-- | One US liquid pint is one half of a <a>usQuart</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usPint
--   4.73176473e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usPint :: Volume Rational
--   473176473 % 1000000000000 m^3
--   </pre>
usPint :: Fractional a => Unit 'NonMetric DVolume a

-- | One US liquid cup is one half of a <a>usPint</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usCup
--   2.365882365e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usCup :: Volume Rational
--   473176473 % 2000000000000 m^3
--   </pre>
usCup :: Fractional a => Unit 'NonMetric DVolume a

-- | One US liquid gill is one half of a <a>usCup</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usGill
--   1.1829411825e-4 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usGill :: Volume Rational
--   473176473 % 4000000000000 m^3
--   </pre>
usGill :: Fractional a => Unit 'NonMetric DVolume a

-- | One US fluid ounce is 1<i>128 <a>usGallon</a> or 1</i>8 <a>usCup</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usFluidOunce
--   2.95735295625e-5 m^3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ usFluidOunce :: Volume Rational
--   473176473 % 16000000000000 m^3
--   </pre>
usFluidOunce :: Fractional a => Unit 'NonMetric DVolume a

-- | One Ångström is 1/10 <a>nano</a> <a>meter</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ angstrom
--   1.0e-10 m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ angstrom :: Length Rational
--   1 % 10000000000 m
--   </pre>
angstrom :: Fractional a => Unit 'NonMetric DLength a

-- | One Gauss is 1/10000 <a>tesla</a>.
--   
--   See <a>here</a> for further information.
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ gauss
--   1.0e-4 kg s^-2 A^-1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 *~ gauss :: MagneticFluxDensity Rational
--   1 % 10000 kg s^-2 A^-1
--   </pre>
gauss :: Fractional a => Unit 'NonMetric DMagneticFluxDensity a


-- | Defines convenience functions for inspecting and manipulating
--   quantities with <a>RealFloat</a> floating-point representations.
--   
--   The dimensionally-typed versions of functions from Patrick Perry's
--   <tt>ieee754</tt> package copy that package's API as closely as
--   possible, by permission. In turn they are based on the <tt>tango</tt>
--   math library for the D language.
module Numeric.Units.Dimensional.Float

-- | <a>True</a> if the representation of the argument is too small to be
--   represented in normalized format.
isDenormalized :: RealFloat a => Quantity d a -> Bool

-- | <a>True</a> if the representation of the argument is an IEEE infinity
--   or negative infinity.
--   
--   <pre>
--   &gt;&gt;&gt; isInfinite (_1 / _0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfinite (42 *~ micro farad)
--   False
--   </pre>
isInfinite :: RealFloat a => Quantity d a -> Bool

-- | <a>True</a> if the representation of the argument is an IEEE
--   "not-a-number" (NaN) value.
--   
--   <pre>
--   &gt;&gt;&gt; isNaN _3
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNaN (_1 / _0)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNaN (asin _4)
--   True
--   </pre>
isNaN :: RealFloat a => Quantity d a -> Bool

-- | <a>True</a> if the representation of the argument is an IEEE negative
--   zero.
--   
--   <pre>
--   &gt;&gt;&gt; isNegativeZero _0
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNegativeZero $ (-1e-200 *~ one) * (1e-200 *~ one)
--   True
--   </pre>
isNegativeZero :: RealFloat a => Quantity d a -> Bool

-- | <a>True</a> if the representation of the argument is a number and is
--   not infinite.
--   
--   <pre>
--   &gt;&gt;&gt; isFiniteNumber (_1 / _0)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isFiniteNumber (_0 / _0)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isFiniteNumber (_3 / _2)
--   True
--   </pre>
isFiniteNumber :: RealFloat a => Quantity d a -> Bool

-- | Multiplies a floating-point quantity by an integer power of the radix
--   of the representation type.
--   
--   Use <a>floatRadix</a> to determine the radix.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 3 *~ meter
--   
--   &gt;&gt;&gt; scaleFloat 3 x
--   24.0 m
--   </pre>
scaleFloat :: RealFloat a => Int -> Quantity d a -> Quantity d a

-- | An infinite floating-point quantity.
infinity :: IEEE a => Quantity d a

-- | The smallest representable positive quantity whose representation is
--   normalized.
minNormal :: IEEE a => Quantity d a

-- | The largest representable finite floating-point quantity.
maxFinite :: IEEE a => Quantity d a

-- | The smallest positive value <tt>x</tt> such that <tt>_1 + x</tt> is
--   representable.
epsilon :: IEEE a => Dimensionless a

-- | Default <tt>NaN</tt> quantity.
nan :: IEEE a => Quantity d a

-- | Return the next smallest representable floating-point quantity
--   (<tt>Infinity</tt> and <tt>NaN</tt> are unchanged).
predIEEE :: IEEE a => Quantity d a -> Quantity d a

-- | Return the next largest representable floating-point quantity
--   (<tt>Infinity</tt> and <tt>NaN</tt> are unchanged).
succIEEE :: IEEE a => Quantity d a -> Quantity d a

-- | Given two floating-point quantities with the same sign, return the
--   quantity whose representation is halfway between their representations
--   on the IEEE number line. If the signs of the values differ or either
--   is <tt>NaN</tt>, the value is undefined.
bisectIEEE :: IEEE a => Quantity d a -> Quantity d a -> Quantity d a

-- | <tt>copySign x y</tt> returns the quantity <tt>x</tt> with its sign
--   changed to match that of <tt>y</tt>.
copySign :: IEEE a => Quantity d a -> Quantity d a -> Quantity d a

-- | Quiet <tt>NaN</tt> quantity with a positive integer payload. Payload
--   must be less than <tt>maxNaNPayload</tt> of the representation type.
--   
--   Beware that while some platforms allow using 0 as a payload, this
--   behavior is not portable.
nanWithPayload :: IEEE a => Word64 -> Quantity d a

-- | The payload stored in a <tt>NaN</tt> quantity. Undefined if the
--   argument is not <tt>NaN</tt>.
nanPayload :: IEEE a => Quantity d a -> Word64

-- | Maximum <tt>NaN</tt> payload for type <tt>a</tt>.
maxNaNPayload :: IEEE a => a -> Word64

-- | Return <a>True</a> if two floating-point quantities are <i>exactly</i>
--   (bitwise) equal.
identicalIEEE :: IEEE a => Quantity d a -> Quantity d a -> Bool

-- | Return the minimum of two quantities; if one value is <tt>NaN</tt>,
--   return the other. Prefer the first if both values are <tt>NaN</tt>.
minNum :: RealFloat a => Quantity d a -> Quantity d a -> Quantity d a

-- | Return the maximum of two quantities; if one value is <tt>NaN</tt>,
--   return the other. Prefer the first if both values are <tt>NaN</tt>.
maxNum :: RealFloat a => Quantity d a -> Quantity d a -> Quantity d a

-- | Return the minimum of two quantities; if one value is <tt>NaN</tt>,
--   return it. Prefer the first if both values are <tt>NaN</tt>.
minNaN :: RealFloat a => Quantity d a -> Quantity d a -> Quantity d a

-- | Return the maximum of two quantities; if one value is <tt>NaN</tt>,
--   return it. Prefer the first if both values are <tt>NaN</tt>.
maxNaN :: RealFloat a => Quantity d a -> Quantity d a -> Quantity d a


-- | Defines types for manipulation of quantities with fixed point
--   representations.
module Numeric.Units.Dimensional.FixedPoint

-- | A dimensional value, either a <a>Quantity</a> or a <a>Unit</a>,
--   parameterized by its <a>Dimension</a> and representation.
data family Dimensional v :: Dimension -> Type -> Type

-- | A unit of measurement.
type Unit (m :: Metricality) = Dimensional ('DUnit m)

-- | A dimensional quantity.
type Quantity = SQuantity One

-- | A dimensional quantity, stored as an <tt>ExactPi'</tt> multiple of its
--   value in its dimension's SI coherent unit.
--   
--   The name is an abbreviation for scaled quantity.
type SQuantity s = Dimensional ('DQuantity s)

-- | Encodes whether a unit is a metric unit, that is, whether it can be
--   combined with a metric prefix to form a related unit.
data Metricality

-- | Capable of receiving a metric prefix.
Metric :: Metricality

-- | Incapable of receiving a metric prefix.
NonMetric :: Metricality

-- | Represents a physical dimension in the basis of the 7 SI base
--   dimensions, where the respective dimensions are represented by type
--   variables using the following convention:
--   
--   <ul>
--   <li>l: Length</li>
--   <li>m: Mass</li>
--   <li>t: Time</li>
--   <li>i: Electric current</li>
--   <li>th: Thermodynamic temperature</li>
--   <li>n: Amount of substance</li>
--   <li>j: Luminous intensity</li>
--   </ul>
--   
--   For the equivalent term-level representation, see <a>Dimension'</a>
data Dimension
Dim :: TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> TypeInt -> Dimension

-- | Multiplication of dimensions corresponds to adding of the base
--   dimensions' exponents.
type family (a :: Dimension) * (b :: Dimension)
infixl 7 *

-- | Division of dimensions corresponds to subtraction of the base
--   dimensions' exponents.
type family (a :: Dimension) / (d :: Dimension)
infixl 7 /

-- | Powers of dimensions corresponds to multiplication of the base
--   dimensions' exponents by the exponent.
--   
--   We limit ourselves to integer powers of Dimensionals as fractional
--   powers make little physical sense.
type family (d :: Dimension) ^ (x :: TypeInt)
infixr 8 ^

-- | Roots of dimensions corresponds to division of the base dimensions'
--   exponents by the order of the root.
type family NRoot (d :: Dimension) (x :: TypeInt)

-- | The reciprocal of a dimension is defined as the result of dividing
--   <a>DOne</a> by it, or of negating each of the base dimensions'
--   exponents.
type Recip (d :: Dimension) = DOne / d

-- | A physical dimension, encoded as 7 integers, representing a
--   factorization of the dimension into the 7 SI base dimensions. By
--   convention they are stored in the same order as in the
--   <a>Dimension</a> data kind.
data Dimension'
Dim' :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> Dimension'

-- | Dimensional values inhabit this class, which allows access to a
--   term-level representation of their dimension.
class HasDynamicDimension a => HasDimension a

-- | Obtains a term-level representation of a value's dimension.
dimension :: HasDimension a => a -> Dimension'

-- | A KnownDimension is one for which we can construct a term-level
--   representation. Each validly constructed type of kind <a>Dimension</a>
--   has a <a>KnownDimension</a> instance.
--   
--   While <a>KnownDimension</a> is a constraint synonym, the presence of
--   <tt><a>KnownDimension</a> d</tt> in a context allows use of
--   <tt><a>dimension</a> :: <a>Proxy</a> d -&gt; <a>Dimension'</a></tt>.
type KnownDimension (d :: Dimension) = HasDimension (Proxy d)

-- | Forms a possibly scaled <a>SQuantity</a> by multipliying a number and
--   a unit.
(*~) :: forall s m d a b. (RealFrac a, Integral b, MinCtxt s a) => a -> Unit m d a -> SQuantity s d b
infixl 7 *~

-- | Divides a possibly scaled <a>SQuantity</a> by a <a>Unit</a> of the
--   same physical dimension, obtaining the numerical value of the quantity
--   expressed in that unit.
(/~) :: forall s m d a b. (Real a, Fractional b, MinCtxt s b) => SQuantity s d a -> Unit m d b -> b
infixl 7 /~

-- | Multiplies two <a>Quantity</a>s or two <a>Unit</a>s.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <a>NonMetric</a>.
(*) :: (KnownVariant v1, KnownVariant v2, KnownVariant (v1 * v2), Num a) => Dimensional v1 d1 a -> Dimensional v2 d2 a -> Dimensional (v1 * v2) (d1 * d2) a
infixl 7 *

-- | Divides one <a>Quantity</a> by another or one <a>Unit</a> by another.
--   
--   The intimidating type signature captures the similarity between these
--   operations and ensures that composite <a>Unit</a>s are
--   <tt>NotPrefixable</tt>.
(/) :: (KnownVariant v1, KnownVariant v2, KnownVariant (v1 / v2), Fractional a) => Dimensional v1 d1 a -> Dimensional v2 d2 a -> Dimensional (v1 / v2) (d1 / d2) a
infixl 7 /

-- | Adds two possibly scaled <a>SQuantity</a>s, preserving any scale
--   factor.
--   
--   Use in conjunction with <a>changeRepRound</a> to combine quantities
--   with differing scale factors.
(+) :: Num a => SQuantity s d a -> SQuantity s d a -> SQuantity s d a
infixl 6 +

-- | Subtracts one possibly scaled <a>SQuantity</a> from another,
--   preserving any scale factor.
--   
--   Use in conjunction with <a>changeRepRound</a> to combine quantities
--   with differing scale factors.
(-) :: Num a => SQuantity s d a -> SQuantity s d a -> SQuantity s d a
infixl 6 -

-- | Negates the value of a possibly scaled <a>SQuantity</a>, preserving
--   any scale factor.
negate :: Num a => SQuantity s d a -> SQuantity s d a

-- | Takes the absolute value of a possibly scaled <a>SQuantity</a>,
--   preserving any scale factor.
abs :: Num a => SQuantity s d a -> SQuantity s d a
expD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
logD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
sinD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
cosD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
tanD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
asinD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
acosD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
atanD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
sinhD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
coshD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
tanhD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
asinhD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
acoshD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b
atanhD :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne b

-- | The standard two argument arctangent function. Since it interprets its
--   two arguments in comparison with one another, the input may have any
--   dimension.
atan2D :: (Integral a, Integral b, MinCtxt s1 Double, MinCtxt s2 Double, MinCtxt s3 Double) => SQuantity s1 DOne a -> SQuantity s2 DOne a -> SQuantity s3 DOne b
expVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
logVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
sinVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
cosVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
tanVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
asinVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
acosVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
atanVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
sinhVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
coshVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
tanhVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
asinhVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
acoshVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c
atanhVia :: (Integral a, RealFrac b, Floating b, Integral c, MinCtxt s1 b, MinCtxt s2 b) => Proxy b -> SQuantity s1 DOne a -> SQuantity s2 DOne c

-- | The standard two argument arctangent function. Since it interprets its
--   two arguments in comparison with one another, the input may have any
--   dimension.
atan2Via :: forall s1 s2 s3 a b c d. (Integral a, RealFloat b, Integral c, MinCtxt s1 b, MinCtxt s2 b, MinCtxt s3 b, KnownDimension d) => Proxy b -> SQuantity s1 d a -> SQuantity s2 d a -> SQuantity s3 DOne c

-- | Applies <a>*~</a> to all values in a functor.
(*~~) :: (Functor f, RealFrac a, Integral b, MinCtxt s a) => f a -> Unit m d a -> f (SQuantity s d b)
infixl 7 *~~

-- | Applies <a>/~</a> to all values in a functor.
(/~~) :: (Functor f, Real a, Fractional b, MinCtxt s b) => f (SQuantity s d a) -> Unit m d b -> f b
infixl 7 /~~

-- | The sum of all elements in a list.
sum :: (Num a, Foldable f) => f (SQuantity s d a) -> SQuantity s d a

-- | The arithmetic mean of all elements in a list.
mean :: (Fractional a, Foldable f) => f (SQuantity s d a) -> SQuantity s d a

-- | Rescales a fixed point quantity, accomodating changes both in its
--   scale factor and its representation type.
--   
--   Note that this uses an arbitrary precision representation of
--   <a>pi</a>, which may be quite slow.
rescale :: forall a b d s1 s2. (Integral a, Integral b, KnownExactPi s1, KnownExactPi s2) => SQuantity s1 d a -> SQuantity s2 d b

-- | Rescales a fixed point quantity, accomodating changes both in its
--   scale factor and its representation type.
--   
--   Expected to outperform <a>rescale</a> when a <a>FiniteBits</a> context
--   is available for the source and destination representation types.
rescaleFinite :: (Integral a, FiniteBits a, Integral b, FiniteBits b, KnownExactPi s1, KnownExactPi s2) => SQuantity s1 d a -> SQuantity s2 d b

-- | Approximately rescales a fixed point quantity, accomodating changes
--   both in its scale factor and its representation type.
--   
--   Uses approximate arithmetic by way of an intermediate <a>Double</a>
--   representation.
rescaleD :: (Integral a, Integral b, KnownExactPi s1, KnownExactPi s2) => SQuantity s1 d a -> SQuantity s2 d b

-- | Approximately rescales a fixed point quantity, accomodating changes
--   both in its scale factor and its representation type.
--   
--   Uses approximate arithmetic by way of an intermediate <a>Floating</a>
--   type, to which a proxy must be supplied.
rescaleVia :: forall a b c d s1 s2. (Integral a, RealFrac b, Floating b, Integral c, KnownExactPi s1, KnownExactPi s2) => Proxy b -> SQuantity s1 d a -> SQuantity s2 d c

-- | A KnownVariant is one whose term-level <a>Dimensional</a> values we
--   can represent with an associated data family instance and manipulate
--   with certain functions, not all of which are exported from the
--   package.
--   
--   Each validly constructed type of kind <a>Variant</a> has a
--   <a>KnownVariant</a> instance.
class KnownVariant (v :: Variant)

-- | Maps over the underlying representation of a dimensional value. The
--   caller is responsible for ensuring that the supplied function respects
--   the dimensional abstraction. This means that the function must
--   preserve numerical values, or linearly scale them while preserving the
--   origin.
dmap :: KnownVariant v => (a1 -> a2) -> Dimensional v d a1 -> Dimensional v d a2

-- | Convenient conversion between numerical types while retaining
--   dimensional information.
changeRep :: forall v1 v2 d a b. (KnownVariant v1, KnownVariant v2, CompatibleVariants v1 v2, MinCtxt (ScaleFactor v1 / ScaleFactor v2) b, Real a, Fractional b) => Dimensional v1 d a -> Dimensional v2 d b

-- | Convenient conversion to types with <a>Integral</a> representations
--   using <a>round</a>.
changeRepRound :: forall v1 v2 d a b. (KnownVariant v1, KnownVariant v2, CompatibleVariants v1 v2, MinCtxt (ScaleFactor v1 / ScaleFactor v2) a, RealFrac a, Integral b) => Dimensional v1 d a -> Dimensional v2 d b

-- | Convenient conversion from exactly represented values while retaining
--   dimensional information.
changeRepApproximate :: (KnownVariant v, Floating b) => Dimensional v d ExactPi -> Dimensional v d b

-- | The type-level dimension of dimensionless values.
type DOne = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DLength = 'Dim 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero
type DMass = 'Dim 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero 'Zero
type DTime = 'Dim 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero 'Zero
type DElectricCurrent = 'Dim 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero 'Zero
type DThermodynamicTemperature = 'Dim 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero 'Zero
type DAmountOfSubstance = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1 'Zero
type DLuminousIntensity = 'Dim 'Zero 'Zero 'Zero 'Zero 'Zero 'Zero 'Pos1
type Dimensionless = Quantity DOne
type Length = Quantity DLength
type Mass = Quantity DMass
type Time = Quantity DTime
type ElectricCurrent = Quantity DElectricCurrent
type ThermodynamicTemperature = Quantity DThermodynamicTemperature
type AmountOfSubstance = Quantity DAmountOfSubstance
type LuminousIntensity = Quantity DLuminousIntensity

-- | The constant for zero is polymorphic, allowing it to express zero
--   <a>Length</a> or <a>Capacitance</a> or <a>Velocity</a> etc, in
--   addition to the <a>Dimensionless</a> value zero.
_0 :: Num a => SQuantity s d a

-- | The least positive representable value in a given fixed-point scaled
--   quantity type.
epsilon :: Integral a => SQuantity s d a
_1 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_2 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_3 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_4 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_5 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_6 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_7 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_8 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
_9 :: (Integral a, KnownExactPi s) => SQuantity s DOne a
pi :: (Integral a, KnownExactPi s) => SQuantity s DOne a

-- | Twice <a>pi</a>.
--   
--   For background on <a>tau</a> see
--   <a>http://tauday.com/tau-manifesto</a> (but also feel free to review
--   <a>http://www.thepimanifesto.com)</a>.
tau :: (Integral a, KnownExactPi s) => SQuantity s DOne a

-- | A polymorphic <a>Unit</a> which can be used in place of the coherent
--   SI base unit of any dimension. This allows polymorphic quantity
--   creation and destruction without exposing the <a>Dimensional</a>
--   constructor.
siUnit :: forall d a. (KnownDimension d, Num a) => Unit 'NonMetric d a

-- | The unit <a>one</a> has dimension <a>DOne</a> and is the base unit of
--   dimensionless values.
--   
--   As detailed in 7.10 "Values of quantities expressed simply as numbers:
--   the unit one, symbol 1" of <a>[1]</a> the unit one generally does not
--   appear in expressions. However, for us it is necessary to use
--   <a>one</a> as we would any other unit to perform the "boxing" of
--   dimensionless values.
one :: Num a => Unit 'NonMetric DOne a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is
--   irrational or <a>Approximate</a>. See <a>mkUnitQ</a> for when it is
--   rational and <a>mkUnitZ</a> for when it is an integer.
--   
--   Note that supplying zero as a definining quantity is invalid, as the
--   library relies upon units forming a group under multiplication.
--   
--   Supplying negative defining quantities is allowed and handled
--   gracefully, but is discouraged on the grounds that it may be
--   unexpected by other readers.
mkUnitR :: Floating a => UnitName m -> ExactPi -> Unit m1 d a -> Unit m d a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is
--   rational. See <a>mkUnitZ</a> for when it is an integer and
--   <a>mkUnitR</a> for the general case.
--   
--   For more information see <a>mkUnitR</a>.
mkUnitQ :: Fractional a => UnitName m -> Rational -> Unit m1 d a -> Unit m d a

-- | Forms a new atomic <a>Unit</a> by specifying its <a>UnitName</a> and
--   its definition as a multiple of another <a>Unit</a>.
--   
--   Use this variant when the scale factor of the resulting unit is an
--   integer. See <a>mkUnitQ</a> for when it is rational and <a>mkUnitR</a>
--   for the general case.
--   
--   For more information see <a>mkUnitR</a>.
mkUnitZ :: Num a => UnitName m -> Integer -> Unit m1 d a -> Unit m d a

-- | Extracts the <a>UnitName</a> of a <a>Unit</a>.
name :: Unit m d a -> UnitName m

-- | Extracts the exact value of a <a>Unit</a>, expressed in terms of the
--   SI coherent derived unit (see <a>siUnit</a>) of the same
--   <a>Dimension</a>.
--   
--   Note that the actual value may in some cases be approximate, for
--   example if the unit is defined by experiment.
exactValue :: Unit m d a -> ExactPi

-- | Discards potentially unwanted type level information about a
--   <a>Unit</a>.
weaken :: Unit m d a -> Unit 'NonMetric d a

-- | Attempts to convert a <a>Unit</a> which may or may not be
--   <a>Metric</a> to one which is certainly <a>Metric</a>.
strengthen :: Unit m d a -> Maybe (Unit 'Metric d a)

-- | Forms the exact version of a <a>Unit</a>.
exactify :: Unit m d a -> Unit m d ExactPi

-- | A dimensionless number with <tt>n</tt> fractional bits, using a
--   representation of type <tt>a</tt>.
type Q n a = SQuantity (QScale n) DOne a

-- | A binary scale factor.
type QScale n = (One / (ExactNatural (2 ^ n)))

-- | A single-turn angle represented as a signed 8-bit integer.
type Angle8 = SQuantity (Pi * (QScale 7)) DPlaneAngle Int8

-- | A single-turn angle represented as a signed 16-bit integer.
type Angle16 = SQuantity (Pi * (QScale 15)) DPlaneAngle Int16

-- | A single-turn angle represented as a signed 32-bit integer.
type Angle32 = SQuantity (Pi * (QScale 31)) DPlaneAngle Int32


-- | Provides a <a>Functor</a> instance for <a>Dimensional</a>.
--   
--   Note that this instance is dubious, because it allows you to break the
--   dimensional abstraction. See <a>dmap</a> for more information.
--   
--   Note that, while this instance overlaps with that given for
--   <a>Dimensionless</a>, it is confluent with that instance.
--   
--   Note that this is an orphan instance.
module Numeric.Units.Dimensional.Functor
instance Numeric.Units.Dimensional.Internal.KnownVariant v => GHC.Base.Functor (Numeric.Units.Dimensional.Internal.Dimensional v d)


-- | Defines types for manipulation of units and quantities without phantom
--   types for their dimensions.
module Numeric.Units.Dimensional.Dynamic

-- | A <a>Quantity</a> whose <a>Dimension</a> is only known dynamically.
data AnyQuantity a

-- | Possibly a <a>Quantity</a> whose <a>Dimension</a> is only known
--   dynamically.
--   
--   By modeling the absence of a value, this type differs from
--   <a>AnyQuantity</a> in that it may not be a <a>Quantity</a> of any
--   <a>Dimension</a> whatsoever, but in exchange it gains instances for
--   the common numeric classes. It's therefore useful for manipulating,
--   and not merely storing, quantities of unknown dimension.
--   
--   This type also contains a <a>polydimensionalZero</a>, representing
--   zero value of any dimension.
--   
--   Note that the <a>Eq</a> instance for <a>DynQuantity</a> equates all
--   representations of an invalid value, and also does not equate
--   polydimensional zero with zero of any specific dimension.
data DynQuantity a

-- | The class of types that can be used to model <a>Quantity</a>s that are
--   certain to have a value with some dimension.
class Demotable (q :: Type -> Type)

-- | The class of types that can be used to model <a>Quantity</a>s whose
--   <a>Dimension</a>s are only known dynamically.
class Promotable (q :: Type -> Type)

-- | Dimensional values, or those that are only possibly dimensional,
--   inhabit this class, which allows access to a term-level representation
--   of their dimension.
class HasDynamicDimension a

-- | Gets the 'DynamicDimension of a dynamic dimensional value, which may
--   be <a>NoDimension</a> if it does not represent a dimensional value of
--   any <tt>Dimension</tt>.
--   
--   A default implementation is available for types that are also in the
--   <a>HasDimension</a> typeclass.
dynamicDimension :: HasDynamicDimension a => a -> DynamicDimension

-- | Gets the 'DynamicDimension of a dynamic dimensional value, which may
--   be <a>NoDimension</a> if it does not represent a dimensional value of
--   any <tt>Dimension</tt>.
--   
--   A default implementation is available for types that are also in the
--   <a>HasDimension</a> typeclass.
dynamicDimension :: (HasDynamicDimension a, HasDimension a) => a -> DynamicDimension

-- | The dimension of a dynamic value, which may not have any dimension at
--   all.
data DynamicDimension

-- | The value has no valid dimension.
NoDimension :: DynamicDimension

-- | The value has the given dimension.
SomeDimension :: Dimension' -> DynamicDimension

-- | The value may be interpreted as having any dimension.
AnyDimension :: DynamicDimension

-- | Converts a dynamic quantity such as an <a>AnyQuantity</a> or a
--   <a>DynQuantity</a> into a <a>Quantity</a>, or to <a>Nothing</a> if the
--   dynamic quantity cannot be represented in the narrower result type.
promoteQuantity :: forall a d q. (Promotable q, KnownDimension d) => q a -> Maybe (Quantity d a)

-- | Forgets information about a <a>Quantity</a> or <a>AnyQuantity</a>,
--   yielding an <a>AnyQuantity</a> or a <a>DynQuantity</a>.
demoteQuantity :: (Demotable q, Promotable d) => q a -> d a

-- | Forms a dynamic quantity by multipliying a number and a dynamic unit.
(*~) :: (Floating a, Promotable q) => a -> AnyUnit -> q a

-- | Divides a dynamic quantity by a dynamic unit, obtaining the numerical
--   value of the quantity expressed in that unit if they are of the same
--   physical dimension, or <a>Nothing</a> otherwise.
(/~) :: (Floating a, Promotable q) => q a -> AnyUnit -> Maybe a

-- | A <a>DynQuantity</a> which does not correspond to a value of any
--   dimension.
invalidQuantity :: DynQuantity a

-- | A <a>DynQuantity</a> which corresponds to zero value of any dimension.
--   
--   When combined through arithmetic with other <a>DynQuantity</a>s,
--   inference is performed. For example, adding a length to
--   polydimensional zero produces that length. Adding two polydimensional
--   zeros produces another. Taking the sine of a polydimensional zero
--   interprets it as a dimensionless zero and produces a dimensionless
--   result.
--   
--   Note that division by <a>polydimensionalZero</a> produces a
--   polydimensional result, which may be an error or some representation
--   of infinity, as determined by the underlying arithmetic type. This
--   behavior was chosen for consistency with the behavior of division by
--   zero <a>DynQuantity</a>s of a specific dimension.
polydimensionalZero :: Num a => DynQuantity a

-- | A <a>Unit</a> whose <a>Dimension</a> is only known dynamically.
data AnyUnit

-- | Converts a <a>Unit</a> of statically known <a>Dimension</a> into an
--   <a>AnyUnit</a>.
demoteUnit :: forall m d a. KnownDimension d => Unit m d a -> AnyUnit

-- | Converts an <a>AnyUnit</a> into a <a>Unit</a> of statically known
--   <a>Dimension</a>, or <a>Nothing</a> if the dimension does not match.
--   
--   The result is represented in <a>ExactPi</a>, conversion to other
--   representations is possible using <a>changeRepApproximate</a>.
--   
--   The result is always tagged as <a>NonMetric</a>, conversion to a
--   <a>Metric</a> unit can be attempted using <a>strengthen</a>.
promoteUnit :: forall d. KnownDimension d => AnyUnit -> Maybe (Unit 'NonMetric d ExactPi)

-- | Converts a <a>Unit</a> of statically known <a>Dimension</a> into an
--   <a>AnyUnit</a>.
--   
--   This is the same as the more general <a>demoteUnit</a> but is useful
--   in certain circumstances to avoid needlessly introducing an ambiguous
--   type variable.
demoteUnit' :: KnownDimension d => Unit m d ExactPi -> AnyUnit

-- | The dynamic SI coherent unit of a given dimension.
siUnit :: Dimension' -> AnyUnit
anyUnitName :: AnyUnit -> UnitName 'NonMetric

-- | Forms the product of two dynamic units.
(*) :: AnyUnit -> AnyUnit -> AnyUnit

-- | Forms the quotient of two dynamic units.
(/) :: AnyUnit -> AnyUnit -> AnyUnit

-- | Raises a dynamic unit to an integer power.
(^) :: Integral a => AnyUnit -> a -> AnyUnit

-- | Forms the reciprocal of a dynamic unit.
recip :: AnyUnit -> AnyUnit

-- | Applies a prefix to a dynamic unit. Returns <a>Nothing</a> if the
--   <a>Unit</a> was <a>NonMetric</a> and thus could not accept a prefix.
applyPrefix :: Prefix -> AnyUnit -> Maybe AnyUnit
instance GHC.Generics.Generic Numeric.Units.Dimensional.Dynamic.AnyUnit
instance GHC.Generics.Generic1 Numeric.Units.Dimensional.Dynamic.DynQuantity
instance GHC.Generics.Generic (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance Data.Data.Data a => Data.Data.Data (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Generics.Generic1 Numeric.Units.Dimensional.Dynamic.AnyQuantity
instance GHC.Generics.Generic (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance Data.Data.Data a => Data.Data.Data (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance GHC.Show.Show Numeric.Units.Dimensional.Dynamic.AnyUnit
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDynamicDimension Numeric.Units.Dimensional.Dynamic.AnyUnit
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDimension Numeric.Units.Dimensional.Dynamic.AnyUnit
instance Numeric.Units.Dimensional.UnitNames.InterchangeNames.HasInterchangeName Numeric.Units.Dimensional.Dynamic.AnyUnit
instance GHC.Base.Semigroup Numeric.Units.Dimensional.Dynamic.AnyUnit
instance GHC.Base.Monoid Numeric.Units.Dimensional.Dynamic.AnyUnit
instance Numeric.Units.Dimensional.Dynamic.Promotable Numeric.Units.Dimensional.Dynamic.AnyQuantity
instance Numeric.Units.Dimensional.Dynamic.Promotable Numeric.Units.Dimensional.Dynamic.DynQuantity
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDynamicDimension (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Num.Num a => GHC.Num.Num (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Float.Floating a => GHC.Float.Floating (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Num.Num a => GHC.Base.Semigroup (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance GHC.Num.Num a => GHC.Base.Monoid (Numeric.Units.Dimensional.Dynamic.DynQuantity a)
instance Numeric.Units.Dimensional.Dimensions.TypeLevel.KnownDimension d => Numeric.Units.Dimensional.Dynamic.Demotable (Numeric.Units.Dimensional.Internal.Quantity d)
instance Numeric.Units.Dimensional.Dynamic.Demotable Numeric.Units.Dimensional.Dynamic.AnyQuantity
instance GHC.Show.Show a => GHC.Show.Show (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDynamicDimension (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance Numeric.Units.Dimensional.Dimensions.TermLevel.HasDimension (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance GHC.Num.Num a => GHC.Base.Semigroup (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
instance GHC.Num.Num a => GHC.Base.Monoid (Numeric.Units.Dimensional.Dynamic.AnyQuantity a)
